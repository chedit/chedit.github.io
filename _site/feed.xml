<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Chedit</title>
		<description>Welcome to Chedit</description>
		<link>http://localhost:4000</link>
		<atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>A Web Crawler With asyncio Coroutines</title>
				<description>&lt;h1 id=&quot;a-web-crawler-with-asyncio-coroutines&quot;&gt;A Web Crawler With asyncio Coroutines&lt;/h1&gt;

&lt;h2 id=&quot;a-jesse-jiryu-davis-and-guido-van-rossum&quot;&gt;A. Jesse Jiryu Davis and Guido van Rossum&lt;/h2&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;A. Jesse Jiryu Davis is a staff engineer at MongoDB in New York. He wrote Motor, the async MongoDB Python driver, and he is the lead developer of the MongoDB C Driver and a member of the PyMongo team. He contributes to asyncio and Tornado. He writes at &lt;a href=&quot;http://emptysqua.re/&quot;&gt;http://emptysqua.re&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Guido van Rossum is the creator of Python, one of the major programming languages on and off the web. The Python community refers to him as the BDFL (Benevolent Dictator For Life), a title straight from a Monty Python skit. Guido’s home on the web is http://www.python.org/~guido/.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Classical computer science emphasizes efficient algorithms that complete computations as quickly as possible. But many networked programs spend their time not computing, but holding open many connections that are slow, or have infrequent events. These programs present a very different challenge: to wait for a huge number of network events efficiently. A contemporary approach to this problem is asynchronous I/O, or “async”.&lt;/p&gt;

&lt;p&gt;This chapter presents a simple web crawler. The crawler is an archetypal async application because it waits for many responses, but does little computation. The more pages it can fetch at once, the sooner it completes. If it devotes a thread to each in-flight request, then as the number of concurrent requests rises it will run out of memory or other thread-related resource before it runs out of sockets. It avoids the need for threads by using asynchronous I/O.&lt;/p&gt;

&lt;p&gt;We present the example in three stages. First, we show an async event loop and sketch a crawler that uses the event loop with callbacks: it is very efficient, but extending it to more complex problems would lead to unmanageable spaghetti code. Second, therefore, we show that Python coroutines are both efficient and extensible. We implement simple coroutines in Python using generator functions. In the third stage, we use the full-featured coroutines from Python’s standard “asyncio” library&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fn1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;, and coordinate them using an async queue.&lt;/p&gt;

&lt;h2 id=&quot;the-task&quot;&gt;The Task&lt;/h2&gt;

&lt;p&gt;A web crawler finds and downloads all pages on a website, perhaps to archive or index them. Beginning with a root URL, it fetches each page, parses it for links to unseen pages, and adds these to a queue. It stops when it fetches a page with no unseen links and the queue is empty.&lt;/p&gt;

&lt;p&gt;We can hasten this process by downloading many pages concurrently. As the crawler finds new links, it launches simultaneous fetch operations for the new pages on separate sockets. It parses responses as they arrive, adding new links to the queue. There may come some point of diminishing returns where too much concurrency degrades performance, so we cap the number of concurrent requests, and leave the remaining links in the queue until some in-flight requests complete.&lt;/p&gt;

&lt;h2 id=&quot;the-traditional-approach&quot;&gt;The Traditional Approach&lt;/h2&gt;

&lt;p&gt;How do we make the crawler concurrent? Traditionally we would create a thread pool. Each thread would be in charge of downloading one page at a time over a socket. For example, to download a page from &lt;code class=&quot;highlighter-rouge&quot;&gt;xkcd.com&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;def fetch(url):
    sock = socket.socket()
    sock.connect(('xkcd.com', 80))
    request = 'GET {} HTTP/1.0\r\nHost: xkcd.com\r\n\r\n'.format(url)
    sock.send(request.encode('ascii'))
    response = b''
    chunk = sock.recv(4096)
    while chunk:
        response += chunk
        chunk = sock.recv(4096)

    # Page is now downloaded.
    links = parse_links(response)
    q.add(links)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, socket operations are &lt;em&gt;blocking&lt;/em&gt;: when the thread calls a method like &lt;code class=&quot;highlighter-rouge&quot;&gt;connect&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;recv&lt;/code&gt;, it pauses until the operation completes.&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fn2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; Consequently to download many pages at once, we need many threads. A sophisticated application amortizes the cost of thread-creation by keeping idle threads in a thread pool, then checking them out to reuse them for subsequent tasks; it does the same with sockets in a connection pool.&lt;/p&gt;

&lt;p&gt;And yet, threads are expensive, and operating systems enforce a variety of hard caps on the number of threads a process, user, or machine may have. On Jesse’s system, a Python thread costs around 50k of memory, and starting tens of thousands of threads causes failures. If we scale up to tens of thousands of simultaneous operations on concurrent sockets, we run out of threads before we run out of sockets. Per-thread overhead or system limits on threads are the bottleneck.&lt;/p&gt;

&lt;p&gt;In his influential article “The C10K problem”&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fn3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;, Dan Kegel outlines the limitations of multithreading for I/O concurrency. He begins,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;It’s time for web servers to handle ten thousand clients simultaneously, don’t you think? After all, the web is a big place now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kegel coined the term “C10K” in 1999. Ten thousand connections sounds dainty now, but the problem has changed only in size, not in kind. Back then, using a thread per connection for C10K was impractical. Now the cap is orders of magnitude higher. Indeed, our toy web crawler would work just fine with threads. Yet for very large scale applications, with hundreds of thousands of connections, the cap remains: there is a limit beyond which most systems can still create sockets, but have run out of threads. How can we overcome this?&lt;/p&gt;

&lt;h2 id=&quot;async&quot;&gt;Async&lt;/h2&gt;

&lt;p&gt;Asynchronous I/O frameworks do concurrent operations on a single thread using &lt;em&gt;non-blocking&lt;/em&gt; sockets. In our async crawler, we set the socket non-blocking before we begin to connect to the server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;sock = socket.socket()
sock.setblocking(False)
try:
    sock.connect(('xkcd.com', 80))
except BlockingIOError:
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Irritatingly, a non-blocking socket throws an exception from &lt;code class=&quot;highlighter-rouge&quot;&gt;connect&lt;/code&gt;, even when it is working normally. This exception replicates the irritating behavior of the underlying C function, which sets &lt;code class=&quot;highlighter-rouge&quot;&gt;errno&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;EINPROGRESS&lt;/code&gt; to tell you it has begun.&lt;/p&gt;

&lt;p&gt;Now our crawler needs a way to know when the connection is established, so it can send the HTTP request. We could simply keep trying in a tight loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;request = 'GET {} HTTP/1.0\r\nHost: xkcd.com\r\n\r\n'.format(url)
encoded = request.encode('ascii')

while True:
    try:
        sock.send(encoded)
        break  # Done.
    except OSError as e:
        pass

print('sent')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This method not only wastes electricity, but it cannot efficiently await events on &lt;em&gt;multiple&lt;/em&gt; sockets. In ancient times, BSD Unix’s solution to this problem was &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;, a C function that waits for an event to occur on a non-blocking socket or a small array of them. Nowadays the demand for Internet applications with huge numbers of connections has led to replacements like &lt;code class=&quot;highlighter-rouge&quot;&gt;poll&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;kqueue&lt;/code&gt; on BSD and &lt;code class=&quot;highlighter-rouge&quot;&gt;epoll&lt;/code&gt; on Linux. These APIs are similar to &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;, but perform well with very large numbers of connections.&lt;/p&gt;

&lt;p&gt;Python 3.4’s &lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultSelector&lt;/code&gt; uses the best &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;-like function available on your system. To register for notifications about network I/O, we create a non-blocking socket and register it with the default selector:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;from selectors import DefaultSelector, EVENT_WRITE

selector = DefaultSelector()

sock = socket.socket()a
sock.setblocking(False)
try:
    sock.connect(('xkcd.com', 80))
except BlockingIOError:
    pass

def connected():
    selector.unregister(sock.fileno())
    print('connected!')

selector.register(sock.fileno(), EVENT_WRITE, connected)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We disregard the spurious error and call &lt;code class=&quot;highlighter-rouge&quot;&gt;selector.register&lt;/code&gt;, passing in the socket’s file descriptor and a constant that expresses what event we are waiting for. To be notified when the connection is established, we pass &lt;code class=&quot;highlighter-rouge&quot;&gt;EVENT_WRITE&lt;/code&gt;: that is, we want to know when the socket is “writable”. We also pass a Python function, &lt;code class=&quot;highlighter-rouge&quot;&gt;connected&lt;/code&gt;, to run when that event occurs. Such a function is known as a &lt;em&gt;callback&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;We process I/O notifications as the selector receives them, in a loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;def loop():
    while True:
        events = selector.select()
        for event_key, event_mask in events:
            callback = event_key.data
            callback()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;connected&lt;/code&gt; callback is stored as &lt;code class=&quot;highlighter-rouge&quot;&gt;event_key.data&lt;/code&gt;, which we retrieve and execute once the non-blocking socket is connected.&lt;/p&gt;

&lt;p&gt;Unlike in our fast-spinning loop above, the call to &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt; here pauses, awaiting the next I/O events. Then the loop runs callbacks that are waiting for these events. Operations that have not completed remain pending until some future tick of the event loop.&lt;/p&gt;

&lt;p&gt;What have we demonstrated already? We showed how to begin an operation and execute a callback when the operation is ready. An async &lt;em&gt;framework&lt;/em&gt; builds on the two features we have shown—non-blocking sockets and the event loop—to run concurrent operations on a single thread.&lt;/p&gt;

&lt;p&gt;We have achieved “concurrency” here, but not what is traditionally called “parallelism”. That is, we built a tiny system that does overlapping I/O. It is capable of beginning new operations while others are in flight. It does not actually utilize multiple cores to execute computation in parallel. But then, this system is designed for I/O-bound problems, not CPU-bound ones.&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fn4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So our event loop is efficient at concurrent I/O because it does not devote thread resources to each connection. But before we proceed, it is important to correct a common misapprehension that async is &lt;em&gt;faster&lt;/em&gt; than multithreading. Often it is not—indeed, in Python, an event loop like ours is moderately slower than multithreading at serving a small number of very active connections. In a runtime without a global interpreter lock, threads would perform even better on such a workload. What asynchronous I/O is right for, is applications with many slow or sleepy connections with infrequent events.&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fn5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;programming-with-callbacks&quot;&gt;Programming With Callbacks&lt;/h2&gt;

&lt;p&gt;With the runty async framework we have built so far, how can we build a web crawler? Even a simple URL-fetcher is painful to write.&lt;/p&gt;

&lt;p&gt;We begin with global sets of the URLs we have yet to fetch, and the URLs we have seen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;urls_todo = set(['/'])
seen_urls = set(['/'])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;seen_urls&lt;/code&gt; set includes &lt;code class=&quot;highlighter-rouge&quot;&gt;urls_todo&lt;/code&gt; plus completed URLs. The two sets are initialized with the root URL “/”.&lt;/p&gt;

&lt;p&gt;Fetching a page will require a series of callbacks. The &lt;code class=&quot;highlighter-rouge&quot;&gt;connected&lt;/code&gt; callback fires when a socket is connected, and sends a GET request to the server. But then it must await a response, so it registers another callback. If, when that callback fires, it cannot read the full response yet, it registers again, and so on.&lt;/p&gt;

&lt;p&gt;Let us collect these callbacks into a &lt;code class=&quot;highlighter-rouge&quot;&gt;Fetcher&lt;/code&gt; object. It needs a URL, a socket object, and a place to accumulate the response bytes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;class Fetcher:
    def __init__(self, url):
        self.response = b''  # Empty array of bytes.
        self.url = url
        self.sock = None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We begin by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;Fetcher.fetch&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;# Method on Fetcher class.
    def fetch(self):
        self.sock = socket.socket()
        self.sock.setblocking(False)
        try:
            self.sock.connect(('xkcd.com', 80))
        except BlockingIOError:
            pass

        # Register next callback.
        selector.register(self.sock.fileno(),
                          EVENT_WRITE,
                          self.connected)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; method begins connecting a socket. But notice the method returns before the connection is established. It must return control to the event loop to wait for the connection. To understand why, imagine our whole application was structured so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;# Begin fetching http://xkcd.com/353/
fetcher = Fetcher('/353/')
fetcher.fetch()

while True:
    events = selector.select()
    for event_key, event_mask in events:
        callback = event_key.data
        callback(event_key, event_mask)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All event notifications are processed in the event loop when it calls &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;. Hence &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; must hand control to the event loop, so that the program knows when the socket has connected. Only then does the loop run the &lt;code class=&quot;highlighter-rouge&quot;&gt;connected&lt;/code&gt; callback, which was registered at the end of &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; above.&lt;/p&gt;

&lt;p&gt;Here is the implementation of &lt;code class=&quot;highlighter-rouge&quot;&gt;connected&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;# Method on Fetcher class.
    def connected(self, key, mask):
        print('connected!')
        selector.unregister(key.fd)
        request = 'GET {} HTTP/1.0\r\nHost: xkcd.com\r\n\r\n'.format(self.url)
        self.sock.send(request.encode('ascii'))

        # Register the next callback.
        selector.register(key.fd,
                          EVENT_READ,
                          self.read_response)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The method sends a GET request. A real application would check the return value of &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt; in case the whole message cannot be sent at once. But our request is small and our application unsophisticated. It blithely calls &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;, then waits for a response. Of course, it must register yet another callback and relinquish control to the event loop. The next and final callback, &lt;code class=&quot;highlighter-rouge&quot;&gt;read_response&lt;/code&gt;, processes the server’s reply:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;# Method on Fetcher class.
    def read_response(self, key, mask):
        global stopped

        chunk = self.sock.recv(4096)  # 4k chunk size.
        if chunk:
            self.response += chunk
        else:
            selector.unregister(key.fd)  # Done reading.
            links = self.parse_links()

            # Python set-logic:
            for link in links.difference(seen_urls):
                urls_todo.add(link)
                Fetcher(link).fetch()  # &amp;lt;- New Fetcher.

            seen_urls.update(links)
            urls_todo.remove(self.url)
            if not urls_todo:
                stopped = True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The callback is executed each time the selector sees that the socket is “readable”, which could mean two things: the socket has data or it is closed.&lt;/p&gt;

&lt;p&gt;The callback asks for up to four kilobytes of data from the socket. If less is ready, &lt;code class=&quot;highlighter-rouge&quot;&gt;chunk&lt;/code&gt; contains whatever data is available. If there is more, &lt;code class=&quot;highlighter-rouge&quot;&gt;chunk&lt;/code&gt; is four kilobytes long and the socket remains readable, so the event loop runs this callback again on the next tick. When the response is complete, the server has closed the socket and &lt;code class=&quot;highlighter-rouge&quot;&gt;chunk&lt;/code&gt; is empty.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;parse_links&lt;/code&gt; method, not shown, returns a set of URLs. We start a new fetcher for each new URL, with no concurrency cap. Note a nice feature of async programming with callbacks: we need no mutex around changes to shared data, such as when we add links to &lt;code class=&quot;highlighter-rouge&quot;&gt;seen_urls&lt;/code&gt;. There is no preemptive multitasking, so we cannot be interrupted at arbitrary points in our code.&lt;/p&gt;

&lt;p&gt;We add a global &lt;code class=&quot;highlighter-rouge&quot;&gt;stopped&lt;/code&gt; variable and use it to control the loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;stopped = False

def loop():
    while not stopped:
        events = selector.select()
        for event_key, event_mask in events:
            callback = event_key.data
            callback()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once all pages are downloaded the fetcher stops the global event loop and the program exits.&lt;/p&gt;

&lt;p&gt;This example makes async’s problem plain: spaghetti code. We need some way to express a series of computations and I/O operations, and schedule multiple such series of operations to run concurrently. But without threads, a series of operations cannot be collected into a single function: whenever a function begins an I/O operation, it explicitly saves whatever state will be needed in the future, then returns. You are responsible for thinking about and writing this state-saving code.&lt;/p&gt;

&lt;p&gt;Let us explain what we mean by that. Consider how simply we fetched a URL on a thread with a conventional blocking socket:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;# Blocking version.
def fetch(url):
    sock = socket.socket()
    sock.connect(('xkcd.com', 80))
    request = 'GET {} HTTP/1.0\r\nHost: xkcd.com\r\n\r\n'.format(url)
    sock.send(request.encode('ascii'))
    response = b''
    chunk = sock.recv(4096)
    while chunk:
        response += chunk
        chunk = sock.recv(4096)

    # Page is now downloaded.
    links = parse_links(response)
    q.add(links)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What state does this function remember between one socket operation and the next? It has the socket, a URL, and the accumulating &lt;code class=&quot;highlighter-rouge&quot;&gt;response&lt;/code&gt;. A function that runs on a thread uses basic features of the programming language to store this temporary state in local variables, on its stack. The function also has a “continuation”—that is, the code it plans to execute after I/O completes. The runtime remembers the continuation by storing the thread’s instruction pointer. You need not think about restoring these local variables and the continuation after I/O. It is built in to the language.&lt;/p&gt;

&lt;p&gt;But with a callback-based async framework, these language features are no help. While waiting for I/O, a function must save its state explicitly, because the function returns and loses its stack frame before I/O completes. In lieu of local variables, our callback-based example stores &lt;code class=&quot;highlighter-rouge&quot;&gt;sock&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;response&lt;/code&gt; as attributes of &lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;, the Fetcher instance. In lieu of the instruction pointer, it stores its continuation by registering the callbacks &lt;code class=&quot;highlighter-rouge&quot;&gt;connected&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;read_response&lt;/code&gt;. As the application’s features grow, so does the complexity of the state we manually save across callbacks. Such onerous bookkeeping makes the coder prone to migraines.&lt;/p&gt;

&lt;p&gt;Even worse, what happens if a callback throws an exception, before it schedules the next callback in the chain? Say we did a poor job on the &lt;code class=&quot;highlighter-rouge&quot;&gt;parse_links&lt;/code&gt; method and it throws an exception parsing some HTML:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Traceback (most recent call last):
  File &quot;loop-with-callbacks.py&quot;, line 111, in &amp;lt;module&amp;gt;
    loop()
  File &quot;loop-with-callbacks.py&quot;, line 106, in loop
    callback(event_key, event_mask)
  File &quot;loop-with-callbacks.py&quot;, line 51, in read_response
    links = self.parse_links()
  File &quot;loop-with-callbacks.py&quot;, line 67, in parse_links
    raise Exception('parse error')
Exception: parse error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The stack trace shows only that the event loop was running a callback. We do not remember what led to the error. The chain is broken on both ends: we forgot where we were going and whence we came. This loss of context is called “stack ripping”, and in many cases it confounds the investigator. Stack ripping also prevents us from installing an exception handler for a chain of callbacks, the way a “try / except” block wraps a function call and its tree of descendents.&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fn6&quot;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So, even apart from the long debate about the relative efficiencies of multithreading and async, there is this other debate regarding which is more error-prone: threads are susceptible to data races if you make a mistake synchronizing them, but callbacks are stubborn to debug due to stack ripping.&lt;/p&gt;

&lt;h2 id=&quot;coroutines&quot;&gt;Coroutines&lt;/h2&gt;

&lt;p&gt;We entice you with a promise. It is possible to write asynchronous code that combines the efficiency of callbacks with the classic good looks of multithreaded programming. This combination is achieved with a pattern called “coroutines”. Using Python 3.4’s standard asyncio library, and a package called “aiohttp”, fetching a URL in a coroutine is very direct&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fn7&quot;&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;@asyncio.coroutine
    def fetch(self, url):
        response = yield from self.session.get(url)
        body = yield from response.read()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is also scalable. Compared to the 50k of memory per thread and the operating system’s hard limits on threads, a Python coroutine takes barely 3k of memory on Jesse’s system. Python can easily start hundreds of thousands of coroutines.&lt;/p&gt;

&lt;p&gt;The concept of a coroutine, dating to the elder days of computer science, is simple: it is a subroutine that can be paused and resumed. Whereas threads are preemptively multitasked by the operating system, coroutines multitask cooperatively: they choose when to pause, and which coroutine to run next.&lt;/p&gt;

&lt;p&gt;There are many implementations of coroutines; even in Python there are several. The coroutines in the standard “asyncio” library in Python 3.4 are built upon generators, a Future class, and the “yield from” statement. Starting in Python 3.5, coroutines are a native feature of the language itself&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fn8&quot;&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt;; however, understanding coroutines as they were first implemented in Python 3.4, using pre-existing language facilities, is the foundation to tackle Python 3.5’s native coroutines.&lt;/p&gt;

&lt;p&gt;To explain Python 3.4’s generator-based coroutines, we will engage in an exposition of generators and how they are used as coroutines in asyncio, and trust you will enjoy reading it as much as we enjoyed writing it. Once we have explained generator-based coroutines, we shall use them in our async web crawler.&lt;/p&gt;

&lt;h2 id=&quot;how-python-generators-work&quot;&gt;How Python Generators Work&lt;/h2&gt;

&lt;p&gt;Before you grasp Python generators, you have to understand how regular Python functions work. Normally, when a Python function calls a subroutine, the subroutine retains control until it returns, or throws an exception. Then control returns to the caller:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; def foo():
...     bar()
...
&amp;gt;&amp;gt;&amp;gt; def bar():
...     pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The standard Python interpreter is written in C. The C function that executes a Python function is called, mellifluously, &lt;code class=&quot;highlighter-rouge&quot;&gt;PyEval_EvalFrameEx&lt;/code&gt;. It takes a Python stack frame object and evaluates Python bytecode in the context of the frame. Here is the bytecode for &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; import dis
&amp;gt;&amp;gt;&amp;gt; dis.dis(foo)
  2           0 LOAD_GLOBAL              0 (bar)
              3 CALL_FUNCTION            0 (0 positional, 0 keyword pair)
              6 POP_TOP
              7 LOAD_CONST               0 (None)
             10 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; function loads &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt; onto its stack and calls it, then pops its return value from the stack, loads &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt; onto the stack, and returns &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;PyEval_EvalFrameEx&lt;/code&gt; encounters the &lt;code class=&quot;highlighter-rouge&quot;&gt;CALL_FUNCTION&lt;/code&gt; bytecode, it creates a new Python stack frame and recurses: that is, it calls &lt;code class=&quot;highlighter-rouge&quot;&gt;PyEval_EvalFrameEx&lt;/code&gt; recursively with the new frame, which is used to execute &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It is crucial to understand that Python stack frames are allocated in heap memory! The Python interpreter is a normal C program, so its stack frames are normal stack frames. But the &lt;em&gt;Python&lt;/em&gt; stack frames it manipulates are on the heap. Among other surprises, this means a Python stack frame can outlive its function call. To see this interactively, save the current frame from within &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; import inspect
&amp;gt;&amp;gt;&amp;gt; frame = None
&amp;gt;&amp;gt;&amp;gt; def foo():
...     bar()
...
&amp;gt;&amp;gt;&amp;gt; def bar():
...     global frame
...     frame = inspect.currentframe()
...
&amp;gt;&amp;gt;&amp;gt; foo()
&amp;gt;&amp;gt;&amp;gt; # The frame was executing the code for 'bar'.
&amp;gt;&amp;gt;&amp;gt; frame.f_code.co_name
'bar'
&amp;gt;&amp;gt;&amp;gt; # Its back pointer refers to the frame for 'foo'.
&amp;gt;&amp;gt;&amp;gt; caller_frame = frame.f_back
&amp;gt;&amp;gt;&amp;gt; caller_frame.f_code.co_name
'foo'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://aosabook.org/en/500L/crawler-images/function-calls.png&quot; alt=&quot;Figure 5.1 - Function Calls&quot; title=&quot;Figure 5.1 - Function Calls&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Figure 5.1 - Function Calls&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;The stage is now set for Python generators, which use the same building blocks—code objects and stack frames—to marvelous effect.&lt;/p&gt;

&lt;p&gt;This is a generator function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; def gen_fn():
...     result = yield 1
...     print('result of yield: {}'.format(result))
...     result2 = yield 2
...     print('result of 2nd yield: {}'.format(result2))
...     return 'done'
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When Python compiles &lt;code class=&quot;highlighter-rouge&quot;&gt;gen_fn&lt;/code&gt; to bytecode, it sees the &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; statement and knows that &lt;code class=&quot;highlighter-rouge&quot;&gt;gen_fn&lt;/code&gt; is a generator function, not a regular one. It sets a flag to remember this fact:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; # The generator flag is bit position 5.
&amp;gt;&amp;gt;&amp;gt; generator_bit = 1 &amp;lt;&amp;lt; 5
&amp;gt;&amp;gt;&amp;gt; bool(gen_fn.__code__.co_flags &amp;amp; generator_bit)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you call a generator function, Python sees the generator flag, and it does not actually run the function. Instead, it creates a generator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; gen = gen_fn()
&amp;gt;&amp;gt;&amp;gt; type(gen)
&amp;lt;class 'generator'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Python generator encapsulates a stack frame plus a reference to some code, the body of &lt;code class=&quot;highlighter-rouge&quot;&gt;gen_fn&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; gen.gi_code.co_name
'gen_fn'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All generators from calls to &lt;code class=&quot;highlighter-rouge&quot;&gt;gen_fn&lt;/code&gt; point to this same code. But each has its own stack frame. This stack frame is not on any actual stack, it sits in heap memory waiting to be used:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://aosabook.org/en/500L/crawler-images/generator.png&quot; alt=&quot;Figure 5.2 - Generators&quot; title=&quot;Figure 5.2 - Generators&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Figure 5.2 - Generators&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;The frame has a “last instruction” pointer, the instruction it executed most recently. In the beginning, the last instruction pointer is -1, meaning the generator has not begun:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; gen.gi_frame.f_lasti
-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we call &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;, the generator reaches its first &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt;, and pauses. The return value of &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt; is 1, since that is what &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt; passes to the &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; gen.send(None)
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The generator’s instruction pointer is now 3 bytecodes from the start, part way through the 56 bytes of compiled Python:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; gen.gi_frame.f_lasti
3
&amp;gt;&amp;gt;&amp;gt; len(gen.gi_code.co_code)
56
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The generator can be resumed at any time, from any function, because its stack frame is not actually on the stack: it is on the heap. Its position in the call hierarchy is not fixed, and it need not obey the first-in, last-out order of execution that regular functions do. It is liberated, floating free like a cloud.&lt;/p&gt;

&lt;p&gt;We can send the value “hello” into the generator and it becomes the result of the &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; expression, and the generator continues until it yields 2:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; gen.send('hello')
result of yield: hello
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Its stack frame now contains the local variable &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; gen.gi_frame.f_locals
{'result': 'hello'}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other generators created from &lt;code class=&quot;highlighter-rouge&quot;&gt;gen_fn&lt;/code&gt; will have their own stack frames and local variables.&lt;/p&gt;

&lt;p&gt;When we call &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt; again, the generator continues from its second &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt;, and finishes by raising the special &lt;code class=&quot;highlighter-rouge&quot;&gt;StopIteration&lt;/code&gt; exception:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; gen.send('goodbye')
result of 2nd yield: goodbye
Traceback (most recent call last):
  File &quot;&amp;lt;input&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration: done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The exception has a value, which is the return value of the generator: the string &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;done&quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;building-coroutines-with-generators&quot;&gt;Building Coroutines With Generators&lt;/h2&gt;

&lt;p&gt;So a generator can pause, and it can be resumed with a value, and it has a return value. Sounds like a good primitive upon which to build an async programming model, without spaghetti callbacks! We want to build a “coroutine”: a routine that is cooperatively scheduled with other routines in the program. Our coroutines will be a simplified version of those in Python’s standard “asyncio” library. As in asyncio, we will use generators, futures, and the “yield from” statement.&lt;/p&gt;

&lt;p&gt;First we need a way to represent some future result that a coroutine is waiting for. A stripped-down version:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;class Future:
    def __init__(self):
        self.result = None
        self._callbacks = []

    def add_done_callback(self, fn):
        self._callbacks.append(fn)

    def set_result(self, result):
        self.result = result
        for fn in self._callbacks:
            fn(self)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A future is initially “pending”. It is “resolved” by a call to &lt;code class=&quot;highlighter-rouge&quot;&gt;set_result&lt;/code&gt;.&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fn9&quot;&gt;&lt;sup&gt;9&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let us adapt our fetcher to use futures and coroutines. We wrote &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; with a callback:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;class Fetcher:
    def fetch(self):
        self.sock = socket.socket()
        self.sock.setblocking(False)
        try:
            self.sock.connect(('xkcd.com', 80))
        except BlockingIOError:
            pass
        selector.register(self.sock.fileno(),
                          EVENT_WRITE,
                          self.connected)

    def connected(self, key, mask):
        print('connected!')
        # And so on....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; method begins connecting a socket, then registers the callback, &lt;code class=&quot;highlighter-rouge&quot;&gt;connected&lt;/code&gt;, to be executed when the socket is ready. Now we can combine these two steps into one coroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;def fetch(self):
        sock = socket.socket()
        sock.setblocking(False)
        try:
            sock.connect(('xkcd.com', 80))
        except BlockingIOError:
            pass

        f = Future()

        def on_connected():
            f.set_result(None)

        selector.register(sock.fileno(),
                          EVENT_WRITE,
                          on_connected)
        yield f
        selector.unregister(sock.fileno())
        print('connected!')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; is a generator function, rather than a regular one, because it contains a &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; statement. We create a pending future, then yield it to pause &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; until the socket is ready. The inner function &lt;code class=&quot;highlighter-rouge&quot;&gt;on_connected&lt;/code&gt; resolves the future.&lt;/p&gt;

&lt;p&gt;But when the future resolves, what resumes the generator? We need a coroutine &lt;em&gt;driver&lt;/em&gt;. Let us call it “task”:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;class Task:
    def __init__(self, coro):
        self.coro = coro
        f = Future()
        f.set_result(None)
        self.step(f)

    def step(self, future):
        try:
            next_future = self.coro.send(future.result)
        except StopIteration:
            return

        next_future.add_done_callback(self.step)

# Begin fetching http://xkcd.com/353/
fetcher = Fetcher('/353/')
Task(fetcher.fetch())

loop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The task starts the &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; generator by sending &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt; into it. Then &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; runs until it yields a future, which the task captures as &lt;code class=&quot;highlighter-rouge&quot;&gt;next_future&lt;/code&gt;. When the socket is connected, the event loop runs the callback &lt;code class=&quot;highlighter-rouge&quot;&gt;on_connected&lt;/code&gt;, which resolves the future, which calls &lt;code class=&quot;highlighter-rouge&quot;&gt;step&lt;/code&gt;, which resumes &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;factoring-coroutines-with-yield-from&quot;&gt;Factoring Coroutines With &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Once the socket is connected, we send the HTTP GET request and read the server response. These steps need no longer be scattered among callbacks; we gather them into the same generator function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;def fetch(self):
        # ... connection logic from above, then:
        sock.send(request.encode('ascii'))

        while True:
            f = Future()

            def on_readable():
                f.set_result(sock.recv(4096))

            selector.register(sock.fileno(),
                              EVENT_READ,
                              on_readable)
            chunk = yield f
            selector.unregister(sock.fileno())
            if chunk:
                self.response += chunk
            else:
                # Done reading.
                break
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code, which reads a whole message from a socket, seems generally useful. How can we factor it from &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; into a subroutine? Now Python 3’s celebrated &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; takes the stage. It lets one generator &lt;em&gt;delegate&lt;/em&gt; to another.&lt;/p&gt;

&lt;p&gt;To see how, let us return to our simple generator example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; def gen_fn():
...     result = yield 1
...     print('result of yield: {}'.format(result))
...     result2 = yield 2
...     print('result of 2nd yield: {}'.format(result2))
...     return 'done'
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To call this generator from another generator, delegate to it with &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; # Generator function:
&amp;gt;&amp;gt;&amp;gt; def caller_fn():
...     gen = gen_fn()
...     rv = yield from gen
...     print('return value of yield-from: {}'
...           .format(rv))
...
&amp;gt;&amp;gt;&amp;gt; # Make a generator from the
&amp;gt;&amp;gt;&amp;gt; # generator function.
&amp;gt;&amp;gt;&amp;gt; caller = caller_fn()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; generator acts as if it were &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt;, the generator it is delegating to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; caller.send(None)
1
&amp;gt;&amp;gt;&amp;gt; caller.gi_frame.f_lasti
15
&amp;gt;&amp;gt;&amp;gt; caller.send('hello')
result of yield: hello
2
&amp;gt;&amp;gt;&amp;gt; caller.gi_frame.f_lasti  # Hasn't advanced.
15
&amp;gt;&amp;gt;&amp;gt; caller.send('goodbye')
result of 2nd yield: goodbye
return value of yield-from: done
Traceback (most recent call last):
  File &quot;&amp;lt;input&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; yields from &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; does not advance. Notice that its instruction pointer remains at 15, the site of its &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; statement, even while the inner generator &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt; advances from one &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; statement to the next.&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fn10&quot;&gt;&lt;sup&gt;10&lt;/sup&gt;&lt;/a&gt; From our perspective outside &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt;, we cannot tell if the values it yields are from &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; or from the generator it delegates to. And from inside &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt;, we cannot tell if values are sent in from &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; or from outside it. The &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; statement is a frictionless channel, through which values flow in and out of &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt; until &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt; completes.&lt;/p&gt;

&lt;p&gt;A coroutine can delegate work to a sub-coroutine with &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; and receive the result of the work. Notice, above, that &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt; printed “return value of yield-from: done”. When &lt;code class=&quot;highlighter-rouge&quot;&gt;gen&lt;/code&gt; completed, its return value became the value of the &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; statement in &lt;code class=&quot;highlighter-rouge&quot;&gt;caller&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;rv = yield from gen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Earlier, when we criticized callback-based async programming, our most strident complaint was about “stack ripping”: when a callback throws an exception, the stack trace is typically useless. It only shows that the event loop was running the callback, not &lt;em&gt;why&lt;/em&gt;. How do coroutines fare?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; def gen_fn():
...     raise Exception('my error')
&amp;gt;&amp;gt;&amp;gt; caller = caller_fn()
&amp;gt;&amp;gt;&amp;gt; caller.send(None)
Traceback (most recent call last):
  File &quot;&amp;lt;input&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
  File &quot;&amp;lt;input&amp;gt;&quot;, line 3, in caller_fn
  File &quot;&amp;lt;input&amp;gt;&quot;, line 2, in gen_fn
Exception: my error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is much more useful! The stack trace shows &lt;code class=&quot;highlighter-rouge&quot;&gt;caller_fn&lt;/code&gt; was delegating to &lt;code class=&quot;highlighter-rouge&quot;&gt;gen_fn&lt;/code&gt; when it threw the error. Even more comforting, we can wrap the call to a sub-coroutine in an exception handler, the same is with normal subroutines:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; def gen_fn():
...     yield 1
...     raise Exception('uh oh')
...
&amp;gt;&amp;gt;&amp;gt; def caller_fn():
...     try:
...         yield from gen_fn()
...     except Exception as exc:
...         print('caught {}'.format(exc))
...
&amp;gt;&amp;gt;&amp;gt; caller = caller_fn()
&amp;gt;&amp;gt;&amp;gt; caller.send(None)
1
&amp;gt;&amp;gt;&amp;gt; caller.send('hello')
caught uh oh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we factor logic with sub-coroutines just like with regular subroutines. Let us factor some useful sub-coroutines from our fetcher. We write a &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; coroutine to receive one chunk:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;def read(sock):
    f = Future()

    def on_readable():
        f.set_result(sock.recv(4096))

    selector.register(sock.fileno(), EVENT_READ, on_readable)
    chunk = yield f  # Read one chunk.
    selector.unregister(sock.fileno())
    return chunk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We build on &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; with a &lt;code class=&quot;highlighter-rouge&quot;&gt;read_all&lt;/code&gt; coroutine that receives a whole message:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;def read_all(sock):
    response = []
    # Read whole response.
    chunk = yield from read(sock)
    while chunk:
        response.append(chunk)
        chunk = yield from read(sock)

    return b''.join(response)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you squint the right way, the &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; statements disappear and these look like conventional functions doing blocking I/O. But in fact, &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;read_all&lt;/code&gt; are coroutines. Yielding from &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; pauses &lt;code class=&quot;highlighter-rouge&quot;&gt;read_all&lt;/code&gt; until the I/O completes. While &lt;code class=&quot;highlighter-rouge&quot;&gt;read_all&lt;/code&gt; is paused, asyncio’s event loop does other work and awaits other I/O events; &lt;code class=&quot;highlighter-rouge&quot;&gt;read_all&lt;/code&gt; is resumed with the result of &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; on the next loop tick once its event is ready.&lt;/p&gt;

&lt;p&gt;At the stack’s root, &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; calls &lt;code class=&quot;highlighter-rouge&quot;&gt;read_all&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;class Fetcher:
    def fetch(self):
         # ... connection logic from above, then:
        sock.send(request.encode('ascii'))
        self.response = yield from read_all(sock)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Miraculously, the Task class needs no modification. It drives the outer &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; coroutine just the same as before:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;Task(fetcher.fetch())
loop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; yields a future, the task receives it through the channel of &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; statements, precisely as if the future were yielded directly from &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt;. When the loop resolves a future, the task sends its result into &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt;, and the value is received by &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt;, exactly as if the task were driving &lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt; directly:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://aosabook.org/en/500L/crawler-images/yield-from.png&quot; alt=&quot;Figure 5.3 - Yield From&quot; title=&quot;Figure 5.3 - Yield From&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Figure 5.3 - Yield From&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;To perfect our coroutine implementation, we polish out one mar: our code uses &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; when it waits for a future, but &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; when it delegates to a sub-coroutine. It would be more refined if we used &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; whenever a coroutine pauses. Then a coroutine need not concern itself with what type of thing it awaits.&lt;/p&gt;

&lt;p&gt;We take advantage of the deep correspondence in Python between generators and iterators. Advancing a generator is, to the caller, the same as advancing an iterator. So we make our Future class iterable by implementing a special method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;# Method on Future class.
    def __iter__(self):
        # Tell Task to resume me here.
        yield self
        return self.result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The future’s &lt;code class=&quot;highlighter-rouge&quot;&gt;__iter__&lt;/code&gt; method is a coroutine that yields the future itself. Now when we replace code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;# f is a Future.
yield f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…with this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;# f is a Future.
yield from f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;…the outcome is the same! The driving Task receives the future from its call to &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;, and when the future is resolved it sends the new result back into the coroutine.&lt;/p&gt;

&lt;p&gt;What is the advantage of using &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; everywhere? Why is that better than waiting for futures with &lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt; and delegating to sub-coroutines with &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt;? It is better because now, a method can freely change its implementation without affecting the caller: it might be a normal method that returns a future that will &lt;em&gt;resolve&lt;/em&gt; to a value, or it might be a coroutine that contains &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; statements and &lt;em&gt;returns&lt;/em&gt; a value. In either case, the caller need only &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; the method in order to wait for the result.&lt;/p&gt;

&lt;p&gt;Gentle reader, we have reached the end of our enjoyable exposition of coroutines in asyncio. We peered into the machinery of generators, and sketched an implementation of futures and tasks. We outlined how asyncio attains the best of both worlds: concurrent I/O that is more efficient than threads and more legible than callbacks. Of course, the real asyncio is much more sophisticated than our sketch. The real framework addresses zero-copy I/O, fair scheduling, exception handling, and an abundance of other features.&lt;/p&gt;

&lt;p&gt;To an asyncio user, coding with coroutines is much simpler than you saw here. In the code above we implemented coroutines from first principles, so you saw callbacks, tasks, and futures. You even saw non-blocking sockets and the call to &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;. But when it comes time to build an application with asyncio, none of this appears in your code. As we promised, you can now sleekly fetch a URL:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;@asyncio.coroutine
    def fetch(self, url):
        response = yield from self.session.get(url)
        body = yield from response.read()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Satisfied with this exposition, we return to our original assignment: to write an async web crawler, using asyncio.&lt;/p&gt;

&lt;h2 id=&quot;coordinating-coroutines&quot;&gt;Coordinating Coroutines&lt;/h2&gt;

&lt;p&gt;We began by describing how we want our crawler to work. Now it is time to implement it with asyncio coroutines.&lt;/p&gt;

&lt;p&gt;Our crawler will fetch the first page, parse its links, and add them to a queue. After this it fans out across the website, fetching pages concurrently. But to limit load on the client and server, we want some maximum number of workers to run, and no more. Whenever a worker finishes fetching a page, it should immediately pull the next link from the queue. We will pass through periods when there is not enough work to go around, so some workers must pause. But when a worker hits a page rich with new links, then the queue suddenly grows and any paused workers should wake and get cracking. Finally, our program must quit once its work is done.&lt;/p&gt;

&lt;p&gt;Imagine if the workers were threads. How would we express the crawler’s algorithm? We could use a synchronized queue&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fn11&quot;&gt;&lt;sup&gt;11&lt;/sup&gt;&lt;/a&gt; from the Python standard library. Each time an item is put in the queue, the queue increments its count of “tasks”. Worker threads call &lt;code class=&quot;highlighter-rouge&quot;&gt;task_done&lt;/code&gt; after completing work on an item. The main thread blocks on &lt;code class=&quot;highlighter-rouge&quot;&gt;Queue.join&lt;/code&gt; until each item put in the queue is matched by a &lt;code class=&quot;highlighter-rouge&quot;&gt;task_done&lt;/code&gt; call, then it exits.&lt;/p&gt;

&lt;p&gt;Coroutines use the exact same pattern with an asyncio queue! First we import it&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fn12&quot;&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;try:
    from asyncio import JoinableQueue as Queue
except ImportError:
    # In Python 3.5, asyncio.JoinableQueue is
    # merged into Queue.
    from asyncio import Queue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We collect the workers’ shared state in a crawler class, and write the main logic in its &lt;code class=&quot;highlighter-rouge&quot;&gt;crawl&lt;/code&gt; method. We start &lt;code class=&quot;highlighter-rouge&quot;&gt;crawl&lt;/code&gt; on a coroutine and run asyncio’s event loop until &lt;code class=&quot;highlighter-rouge&quot;&gt;crawl&lt;/code&gt; finishes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;loop = asyncio.get_event_loop()

crawler = crawling.Crawler('http://xkcd.com',
                           max_redirect=10)

loop.run_until_complete(crawler.crawl())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The crawler begins with a root URL and &lt;code class=&quot;highlighter-rouge&quot;&gt;max_redirect&lt;/code&gt;, the number of redirects it is willing to follow to fetch any one URL. It puts the pair &lt;code class=&quot;highlighter-rouge&quot;&gt;(URL, max_redirect)&lt;/code&gt; in the queue. (For the reason why, stay tuned.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;class Crawler:
    def __init__(self, root_url, max_redirect):
        self.max_tasks = 10
        self.max_redirect = max_redirect
        self.q = Queue()
        self.seen_urls = set()

        # aiohttp's ClientSession does connection pooling and
        # HTTP keep-alives for us.
        self.session = aiohttp.ClientSession(loop=loop)

        # Put (URL, max_redirect) in the queue.
        self.q.put((root_url, self.max_redirect))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The number of unfinished tasks in the queue is now one. Back in our main script, we launch the event loop and the &lt;code class=&quot;highlighter-rouge&quot;&gt;crawl&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;loop.run_until_complete(crawler.crawl())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;crawl&lt;/code&gt; coroutine kicks off the workers. It is like a main thread: it blocks on &lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt; until all tasks are finished, while the workers run in the background.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;@asyncio.coroutine
    def crawl(self):
        &quot;&quot;&quot;Run the crawler until all work is done.&quot;&quot;&quot;
        workers = [asyncio.Task(self.work())
                   for _ in range(self.max_tasks)]

        # When all work is done, exit.
        yield from self.q.join()
        for w in workers:
            w.cancel()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the workers were threads we might not wish to start them all at once. To avoid creating expensive threads until it is certain they are necessary, a thread pool typically grows on demand. But coroutines are cheap, so we simply start the maximum number allowed.&lt;/p&gt;

&lt;p&gt;It is interesting to note how we shut down the crawler. When the &lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt; future resolves, the worker tasks are alive but suspended: they wait for more URLs but none come. So, the main coroutine cancels them before exiting. Otherwise, as the Python interpreter shuts down and calls all objects’ destructors, living tasks cry out:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ERROR:asyncio:Task was destroyed but it is pending!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And how does &lt;code class=&quot;highlighter-rouge&quot;&gt;cancel&lt;/code&gt; work? Generators have a feature we have not yet shown you. You can throw an exception into a generator from outside:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;&amp;gt;&amp;gt;&amp;gt; gen = gen_fn()
&amp;gt;&amp;gt;&amp;gt; gen.send(None)  # Start the generator as usual.
1
&amp;gt;&amp;gt;&amp;gt; gen.throw(Exception('error'))
Traceback (most recent call last):
  File &quot;&amp;lt;input&amp;gt;&quot;, line 3, in &amp;lt;module&amp;gt;
  File &quot;&amp;lt;input&amp;gt;&quot;, line 2, in gen_fn
Exception: error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The generator is resumed by &lt;code class=&quot;highlighter-rouge&quot;&gt;throw&lt;/code&gt;, but it is now raising an exception. If no code in the generator’s call stack catches it, the exception bubbles back up to the top. So to cancel a task’s coroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;# Method of Task class.
    def cancel(self):
        self.coro.throw(CancelledError)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wherever the generator is paused, at some &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; statement, it resumes and throws an exception. We handle cancellation in the task’s &lt;code class=&quot;highlighter-rouge&quot;&gt;step&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;# Method of Task class.
    def step(self, future):
        try:
            next_future = self.coro.send(future.result)
        except CancelledError:
            self.cancelled = True
            return
        except StopIteration:
            return

        next_future.add_done_callback(self.step)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the task knows it is cancelled, so when it is destroyed it does not rage against the dying of the light.&lt;/p&gt;

&lt;p&gt;Once &lt;code class=&quot;highlighter-rouge&quot;&gt;crawl&lt;/code&gt; has canceled the workers, it exits. The event loop sees that the coroutine is complete (we shall see how later), and it too exits:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;loop.run_until_complete(crawler.crawl())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;crawl&lt;/code&gt; method comprises all that our main coroutine must do. It is the worker coroutines that get URLs from the queue, fetch them, and parse them for new links. Each worker runs the &lt;code class=&quot;highlighter-rouge&quot;&gt;work&lt;/code&gt; coroutine independently:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;@asyncio.coroutine
    def work(self):
        while True:
            url, max_redirect = yield from self.q.get()

            # Download page and add new links to self.q.
            yield from self.fetch(url, max_redirect)
            self.q.task_done()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python sees that this code contains &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; statements, and compiles it into a generator function. So in &lt;code class=&quot;highlighter-rouge&quot;&gt;crawl&lt;/code&gt;, when the main coroutine calls &lt;code class=&quot;highlighter-rouge&quot;&gt;self.work&lt;/code&gt; ten times, it does not actually execute this method: it only creates ten generator objects with references to this code. It wraps each in a Task. The Task receives each future the generator yields, and drives the generator by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt; with each future’s result when the future resolves. Because the generators have their own stack frames, they run independently, with separate local variables and instruction pointers.&lt;/p&gt;

&lt;p&gt;The worker coordinates with its fellows via the queue. It waits for new URLs with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;url, max_redirect = yield from self.q.get()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The queue’s &lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt; method is itself a coroutine: it pauses until someone puts an item in the queue, then resumes and returns the item.&lt;/p&gt;

&lt;p&gt;Incidentally, this is where the worker will be paused at the end of the crawl, when the main coroutine cancels it. From the coroutine’s perspective, its last trip around the loop ends when &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; raises a &lt;code class=&quot;highlighter-rouge&quot;&gt;CancelledError&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When a worker fetches a page it parses the links and puts new ones in the queue, then calls &lt;code class=&quot;highlighter-rouge&quot;&gt;task_done&lt;/code&gt; to decrement the counter. Eventually, a worker fetches a page whose URLs have all been fetched already, and there is also no work left in the queue. Thus this worker’s call to &lt;code class=&quot;highlighter-rouge&quot;&gt;task_done&lt;/code&gt; decrements the counter to zero. Then &lt;code class=&quot;highlighter-rouge&quot;&gt;crawl&lt;/code&gt;, which is waiting for the queue’s &lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt; method, is unpaused and finishes.&lt;/p&gt;

&lt;p&gt;We promised to explain why the items in the queue are pairs, like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;# URL to fetch, and the number of redirects left.
('http://xkcd.com/353', 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;New URLs have ten redirects remaining. Fetching this particular URL results in a redirect to a new location with a trailing slash. We decrement the number of redirects remaining, and put the next location in the queue:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;# URL with a trailing slash. Nine redirects left.
('http://xkcd.com/353/', 9)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;aiohttp&lt;/code&gt; package we use would follow redirects by default and give us the final response. We tell it not to, however, and handle redirects in the crawler, so it can coalesce redirect paths that lead to the same destination: if we have already seen this URL, it is in &lt;code class=&quot;highlighter-rouge&quot;&gt;self.seen_urls&lt;/code&gt; and we have already started on this path from a different entry point:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://aosabook.org/en/500L/crawler-images/redirects.png&quot; alt=&quot;Figure 5.4 - Redirects&quot; title=&quot;Figure 5.4 - Redirects&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;Figure 5.4 - Redirects&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;The crawler fetches “foo” and sees it redirects to “baz”, so it adds “baz” to the queue and to &lt;code class=&quot;highlighter-rouge&quot;&gt;seen_urls&lt;/code&gt;. If the next page it fetches is “bar”, which also redirects to “baz”, the fetcher does not enqueue “baz” again. If the response is a page, rather than a redirect, &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; parses it for links and puts new ones in the queue.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;@asyncio.coroutine
    def fetch(self, url, max_redirect):
        # Handle redirects ourselves.
        response = yield from self.session.get(
            url, allow_redirects=False)

        try:
            if is_redirect(response):
                if max_redirect &amp;gt; 0:
                    next_url = response.headers['location']
                    if next_url in self.seen_urls:
                        # We have been down this path before.
                        return

                    # Remember we have seen this URL.
                    self.seen_urls.add(next_url)

                    # Follow the redirect. One less redirect remains.
                    self.q.put_nowait((next_url, max_redirect - 1))
             else:
                 links = yield from self.parse_links(response)
                 # Python set-logic:
                 for link in links.difference(self.seen_urls):
                    self.q.put_nowait((link, self.max_redirect))
                self.seen_urls.update(links)
        finally:
            # Return connection to pool.
            yield from response.release()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If this were multithreaded code, it would be lousy with race conditions. For example, the worker checks if a link is in &lt;code class=&quot;highlighter-rouge&quot;&gt;seen_urls&lt;/code&gt;, and if not the worker puts it in the queue and adds it to &lt;code class=&quot;highlighter-rouge&quot;&gt;seen_urls&lt;/code&gt;. If it were interrupted between the two operations, then another worker might parse the same link from a different page, also observe that it is not in &lt;code class=&quot;highlighter-rouge&quot;&gt;seen_urls&lt;/code&gt;, and also add it to the queue. Now that same link is in the queue twice, leading (at best) to duplicated work and wrong statistics.&lt;/p&gt;

&lt;p&gt;However, a coroutine is only vulnerable to interruption at &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; statements. This is a key difference that makes coroutine code far less prone to races than multithreaded code: multithreaded code must enter a critical section explicitly, by grabbing a lock, otherwise it is interruptible. A Python coroutine is uninterruptible by default, and only cedes control when it explicitly yields.&lt;/p&gt;

&lt;p&gt;We no longer need a fetcher class like we had in the callback-based program. That class was a workaround for a deficiency of callbacks: they need some place to store state while waiting for I/O, since their local variables are not preserved across calls. But the &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; coroutine can store its state in local variables like a regular function does, so there is no more need for a class.&lt;/p&gt;

&lt;p&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; finishes processing the server response it returns to the caller, &lt;code class=&quot;highlighter-rouge&quot;&gt;work&lt;/code&gt;. The &lt;code class=&quot;highlighter-rouge&quot;&gt;work&lt;/code&gt; method calls &lt;code class=&quot;highlighter-rouge&quot;&gt;task_done&lt;/code&gt; on the queue and then gets the next URL from the queue to be fetched.&lt;/p&gt;

&lt;p&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt; puts new links in the queue it increments the count of unfinished tasks and keeps the main coroutine, which is waiting for &lt;code class=&quot;highlighter-rouge&quot;&gt;q.join&lt;/code&gt;, paused. If, however, there are no unseen links and this was the last URL in the queue, then when &lt;code class=&quot;highlighter-rouge&quot;&gt;work&lt;/code&gt; calls &lt;code class=&quot;highlighter-rouge&quot;&gt;task_done&lt;/code&gt; the count of unfinished tasks falls to zero. That event unpauses &lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt; and the main coroutine completes.&lt;/p&gt;

&lt;p&gt;The queue code that coordinates the workers and the main coroutine is like this&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fn13&quot;&gt;&lt;sup&gt;13&lt;/sup&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;class Queue:
    def __init__(self):
        self._join_future = Future()
        self._unfinished_tasks = 0
        # ... other initialization ...

    def put_nowait(self, item):
        self._unfinished_tasks += 1
        # ... store the item ...

    def task_done(self):
        self._unfinished_tasks -= 1
        if self._unfinished_tasks == 0:
            self._join_future.set_result(None)

    @asyncio.coroutine
    def join(self):
        if self._unfinished_tasks &amp;gt; 0:
            yield from self._join_future
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main coroutine, &lt;code class=&quot;highlighter-rouge&quot;&gt;crawl&lt;/code&gt;, yields from &lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt;. So when the last worker decrements the count of unfinished tasks to zero, it signals &lt;code class=&quot;highlighter-rouge&quot;&gt;crawl&lt;/code&gt; to resume, and finish.&lt;/p&gt;

&lt;p&gt;The ride is almost over. Our program began with the call to &lt;code class=&quot;highlighter-rouge&quot;&gt;crawl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;loop.run_until_complete(self.crawler.crawl())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How does the program end? Since &lt;code class=&quot;highlighter-rouge&quot;&gt;crawl&lt;/code&gt; is a generator function, calling it returns a generator. To drive the generator, asyncio wraps it in a task:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;class EventLoop:
    def run_until_complete(self, coro):
        &quot;&quot;&quot;Run until the coroutine is done.&quot;&quot;&quot;
        task = Task(coro)
        task.add_done_callback(stop_callback)
        try:
            self.run_forever()
        except StopError:
            pass

class StopError(BaseException):
    &quot;&quot;&quot;Raised to stop the event loop.&quot;&quot;&quot;

def stop_callback(future):
    raise StopError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the task completes, it raises &lt;code class=&quot;highlighter-rouge&quot;&gt;StopError&lt;/code&gt;, which the loop uses as a signal that it has arrived at normal completion.&lt;/p&gt;

&lt;p&gt;But what’s this? The task has methods called &lt;code class=&quot;highlighter-rouge&quot;&gt;add_done_callback&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;? You might think that a task resembles a future. Your instinct is correct. We must admit a detail about the Task class we hid from you: a task is a future.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;class Task(Future):
    &quot;&quot;&quot;A coroutine wrapped in a Future.&quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Normally a future is resolved by someone else calling &lt;code class=&quot;highlighter-rouge&quot;&gt;set_result&lt;/code&gt; on it. But a task resolves &lt;em&gt;itself&lt;/em&gt; when its coroutine stops. Remember from our earlier exploration of Python generators that when a generator returns, it throws the special &lt;code class=&quot;highlighter-rouge&quot;&gt;StopIteration&lt;/code&gt; exception:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;# Method of class Task.
    def step(self, future):
        try:
            next_future = self.coro.send(future.result)
        except CancelledError:
            self.cancelled = True
            return
        except StopIteration as exc:

            # Task resolves itself with coro's return
            # value.
            self.set_result(exc.value)
            return

        next_future.add_done_callback(self.step)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So when the event loop calls &lt;code class=&quot;highlighter-rouge&quot;&gt;task.add_done_callback(stop_callback)&lt;/code&gt;, it prepares to be stopped by the task. Here is &lt;code class=&quot;highlighter-rouge&quot;&gt;run_until_complete&lt;/code&gt; again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sourceCode&quot;&gt;# Method of event loop.
    def run_until_complete(self, coro):
        task = Task(coro)
        task.add_done_callback(stop_callback)
        try:
            self.run_forever()
        except StopError:
            pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the task catches &lt;code class=&quot;highlighter-rouge&quot;&gt;StopIteration&lt;/code&gt; and resolves itself, the callback raises &lt;code class=&quot;highlighter-rouge&quot;&gt;StopError&lt;/code&gt; from within the loop. The loop stops and the call stack is unwound to &lt;code class=&quot;highlighter-rouge&quot;&gt;run_until_complete&lt;/code&gt;. Our program is finished.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Increasingly often, modern programs are I/O-bound instead of CPU-bound. For such programs, Python threads are the worst of both worlds: the global interpreter lock prevents them from actually executing computations in parallel, and preemptive switching makes them prone to races. Async is often the right pattern. But as callback-based async code grows, it tends to become a dishevelled mess. Coroutines are a tidy alternative. They factor naturally into subroutines, with sane exception handling and stack traces.&lt;/p&gt;

&lt;p&gt;If we squint so that the &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; statements blur, a coroutine looks like a thread doing traditional blocking I/O. We can even coordinate coroutines with classic patterns from multi-threaded programming. There is no need for reinvention. Thus, compared to callbacks, coroutines are an inviting idiom to the coder experienced with multithreading.&lt;/p&gt;

&lt;p&gt;But when we open our eyes and focus on the &lt;code class=&quot;highlighter-rouge&quot;&gt;yield from&lt;/code&gt; statements, we see they mark points when the coroutine cedes control and allows others to run. Unlike threads, coroutines display where our code can be interrupted and where it cannot. In his illuminating essay “Unyielding”&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fn14&quot;&gt;&lt;sup&gt;14&lt;/sup&gt;&lt;/a&gt;, Glyph Lefkowitz writes, “Threads make local reasoning difficult, and local reasoning is perhaps the most important thing in software development.” Explicitly yielding, however, makes it possible to “understand the behavior (and thereby, the correctness) of a routine by examining the routine itself rather than examining the entire system.”&lt;/p&gt;

&lt;p&gt;This chapter was written during a renaissance in the history of Python and async. Generator-based coroutines, whose devising you have just learned, were released in the “asyncio” module with Python 3.4 in March 2014. In September 2015, Python 3.5 was released with coroutines built in to the language itself. These native coroutinesare declared with the new syntax “async def”, and instead of “yield from”, they use the new “await” keyword to delegate to a coroutine or wait for a Future.&lt;/p&gt;

&lt;p&gt;Despite these advances, the core ideas remain. Python’s new native coroutines will be syntactically distinct from generators but work very similarly; indeed, they will share an implementation within the Python interpreter. Task, Future, and the event loop will continue to play their roles in asyncio.&lt;/p&gt;

&lt;p&gt;Now that you know how asyncio coroutines work, you can largely forget the details. The machinery is tucked behind a dapper interface. But your grasp of the fundamentals empowers you to code correctly and efficiently in modern async environments.&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Guido introduced the standard asyncio library, called “Tulip” then, at &lt;a href=&quot;http://pyvideo.org/video/1667/keynote&quot;&gt;PyCon 2013&lt;/a&gt;.&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Even calls to &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt; can block, if the recipient is slow to acknowledge outstanding messages and the system’s buffer of outgoing data is full.&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.kegel.com/c10k.html&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python’s global interpreter lock prohibits running Python code in parallel in one process anyway. Parallelizing CPU-bound algorithms in Python requires multiple processes, or writing the parallel portions of the code in C. But that is a topic for another day.&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jesse listed indications and contraindications for using async in &lt;a href=&quot;http://pyvideo.org/video/2565/what-is-async-how-does-it-work-and-when-should&quot;&gt;“What Is Async, How Does It Work, And When Should I Use It?”:&lt;/a&gt;. Mike Bayer compared the throughput of asyncio and multithreading for different workloads in &lt;a href=&quot;http://techspot.zzzeek.org/2015/02/15/asynchronous-python-and-databases/&quot;&gt;“Asynchronous Python and Databases”:&lt;/a&gt;&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fnref5&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For a complex solution to this problem, see http://www.tornadoweb.org/en/stable/stack_context.html&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fnref6&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;@asyncio.coroutine&lt;/code&gt; decorator is not magical. In fact, if it decorates a generator function and the &lt;code class=&quot;highlighter-rouge&quot;&gt;PYTHONASYNCIODEBUG&lt;/code&gt; environment variable is not set, the decorator does practically nothing. It just sets an attribute, &lt;code class=&quot;highlighter-rouge&quot;&gt;_is_coroutine&lt;/code&gt;, for the convenience of other parts of the framework. It is possible to use asyncio with bare generators not decorated with &lt;code class=&quot;highlighter-rouge&quot;&gt;@asyncio.coroutine&lt;/code&gt; at all.&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fnref7&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python 3.5’s built-in coroutines are described in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;PEP 492&lt;/a&gt;, “Coroutines with async and await syntax.”&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fnref8&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This future has many deficiencies. For example, once this future is resolved, a coroutine that yields it should resume immediately instead of pausing, but with our code it does not. See asyncio’s Future class for a complete implementation.&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fnref9&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In fact, this is exactly how “yield from” works in CPython. A function increments its instruction pointer before executing each statement. But after the outer generator executes “yield from”, it subtracts 1 from its instruction pointer to keep itself pinned at the “yield from” statement. Then it yields to &lt;em&gt;its&lt;/em&gt; caller. The cycle repeats until the inner generator throws &lt;code class=&quot;highlighter-rouge&quot;&gt;StopIteration&lt;/code&gt;, at which point the outer generator finally allows itself to advance to the next instruction.&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fnref10&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://docs.python.org/3/library/queue.html&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fnref11&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://docs.python.org/3/library/asyncio-sync.html&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fnref12&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The actual &lt;code class=&quot;highlighter-rouge&quot;&gt;asyncio.Queue&lt;/code&gt; implementation uses an &lt;code class=&quot;highlighter-rouge&quot;&gt;asyncio.Event&lt;/code&gt; in place of the Future shown here. The difference is an Event can be reset, whereas a Future cannot transition from resolved back to pending.&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fnref13&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://glyph.twistedmatrix.com/2014/02/unyielding.html&lt;a href=&quot;http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#fnref14&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
				<pubDate>Sat, 09 Jun 2018 11:40:51 +0800</pubDate>
				<link>http://localhost:4000/programing/2018/06/09/a-web-crawler-with-asyncio-coroutines.html</link>
				<guid isPermaLink="true">http://localhost:4000/programing/2018/06/09/a-web-crawler-with-asyncio-coroutines.html</guid>
			</item>
		
			<item>
				<title>维基百科保存为MD和打印pdf</title>
				<description>&lt;h1 id=&quot;维基百科保存为md和打印pdf&quot;&gt;维基百科保存为MD和打印pdf&lt;/h1&gt;

&lt;p&gt;维基百科保存为MD，比较好的方案是采用copytomarkdown CHROME插件。
CopyToMarkdown插件采用reMark.js将HTML转换成Markdown格式，总体来说效果还是挺好的。
但是CopytoMarkdown插件保存维基百科也有几个不如意的地方：&lt;/p&gt;

&lt;p&gt;1.维基百科中出现数学公式的地方。维基百科采用Mathjah来显示数学公式，方法和tex的数学公式语法一致。采用CopyToMarkdwon chrome插件，copy出来的数学公式显示成了HTML一大坨，这样在MD格式中预览的时候就是一堆杂乱无章的HTML。&lt;/p&gt;

&lt;p&gt;2.维基百科中的代码源程序，采用copytomarkdown chrome插件，也显示成了HTML格式。比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The traditional [&quot;Hello, world!&quot; program](https://en.wikipedia.org/wiki/%22Hello,_world!%22_program &quot;&quot;Hello, world!&quot; program&quot;) can be written in Java as:&amp;lt;sup id=&quot;cite_ref-51&quot; class=&quot;reference&quot;&amp;gt;[[51]](https://en.wikipedia.org/wiki/Java_(programming_language)#cite_note-51)&amp;lt;/sup&amp;gt;

&amp;lt;pre&amp;gt;
classHelloWorldApp {
    public static void main(String[] args) {
        System.out.println(&quot;Hello World!&quot;); // Prints the string to the console.
    }
}
&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;copy成markdown变成&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## &quot;Hello world&quot; example

The traditional [&quot;Hello, world!&quot; program](https://en.wikipedia.org/wiki/%22Hello,_world!%22_program &quot;&quot;Hello, world!&quot; program&quot;) can be written in Java as:&amp;lt;sup id=&quot;cite_ref-51&quot; class=&quot;reference&quot;&amp;gt;[[51]](https://en.wikipedia.org/wiki/Java_(programming_language)#cite_note-51)&amp;lt;/sup&amp;gt;

&amp;lt;pre&amp;gt;
classHelloWorldApp {
    public static void main(String[] args) {
        System.out.println(&quot;Hello World!&quot;); // Prints the string to the console.
    }
}
&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它是由HTML转换过来的。原来的HTML是下面的样子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;h2&amp;gt;&amp;lt;span class=&quot;mw-headline&quot; id=&quot;.22Hello_world.22_example&quot;&amp;gt;&quot;Hello world&quot; example&amp;lt;/span&amp;gt;&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;The traditional &amp;lt;a href=&quot;/wiki/%22Hello,_world!%22_program&quot; class=&quot;mw-redirect&quot; title=&quot;&amp;amp;quot;Hello, world!&amp;amp;quot; program&quot;&amp;gt;&quot;Hello, world!&quot; program&amp;lt;/a&amp;gt; can be written in Java as:&amp;lt;sup id=&quot;cite_ref-51&quot; class=&quot;reference&quot;&amp;gt;&amp;lt;a href=&quot;#cite_note-51&quot;&amp;gt;[51]&amp;lt;/a&amp;gt;&amp;lt;/sup&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;div class=&quot;mw-highlight mw-content-ltr&quot; dir=&quot;ltr&quot;&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;span class=&quot;kd&quot;&amp;gt;class&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;nc&quot;&amp;gt;HelloWorldApp&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;o&quot;&amp;gt;{&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;kd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kd&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kt&quot;&amp;gt;void&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;nf&quot;&amp;gt;main&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;n&quot;&amp;gt;String&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;[]&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;n&quot;&amp;gt;args&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;)&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;o&quot;&amp;gt;{&amp;lt;/span&amp;gt;
        &amp;lt;span class=&quot;n&quot;&amp;gt;System&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;na&quot;&amp;gt;out&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;na&quot;&amp;gt;println&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;s&quot;&amp;gt;&quot;Hello World!&quot;&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;);&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;c1&quot;&amp;gt;// Prints the string to the console.&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;o&quot;&amp;gt;}&amp;lt;/span&amp;gt;
&amp;lt;span class=&quot;o&quot;&amp;gt;}&amp;lt;/span&amp;gt;
&amp;lt;/pre&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.乱用黑体。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for example, &amp;lt;code&amp;gt;HelloWorldApp.java&amp;lt;/code&amp;gt;. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;转换成了：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for example, `HelloWorldApp.java`. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面的&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A &amp;lt;code&amp;gt;&amp;lt;b&amp;gt;class&amp;lt;/b&amp;gt;&amp;lt;/code&amp;gt; that is not declared &amp;lt;code&amp;gt;&amp;lt;b&amp;gt;public&amp;lt;/b&amp;gt;&amp;lt;/code&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;转换成了&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A `**class**` that is not declared `**public**`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在MARKDOWN中渲染不好看。&lt;/p&gt;

&lt;p&gt;4.表格。维基百科中有很多表格，在使用copytomarkdown后，有些变成了乱码。&lt;/p&gt;

&lt;p&gt;5.图像。维基百科的图像，copytomarkdown后，不能显示。不知道是什么原因。
总体来说，采用copytomarkdown，除了上面几个地方，保存为MD后，还是令人满意的。&lt;/p&gt;
</description>
				<pubDate>Sat, 09 Jun 2018 11:15:51 +0800</pubDate>
				<link>http://localhost:4000/markdown/2018/06/09/wiki-to-markdown-and-pdf.html</link>
				<guid isPermaLink="true">http://localhost:4000/markdown/2018/06/09/wiki-to-markdown-and-pdf.html</guid>
			</item>
		
			<item>
				<title>markdown语法</title>
				<description>&lt;h1 id=&quot;markdown-语法&quot;&gt;markdown 语法&lt;/h1&gt;

&lt;h2 id=&quot;1-排版&quot;&gt;1. 排版&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;粗体&lt;/strong&gt; &lt;em&gt;斜体&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;这是一段错误的文本。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;引用:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;引用Leanote官方的话, 为什么要做Leanote, 原因是…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有充列表:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;支持Vim&lt;/li&gt;
  &lt;li&gt;支持Emacs&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;无序列表:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;项目1&lt;/li&gt;
  &lt;li&gt;项目2&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-图片与链接&quot;&gt;2. 图片与链接&lt;/h2&gt;

&lt;p&gt;图片:&lt;/p&gt;
&lt;center&gt; ![leanote](http://leanote.com/images/logo/leanote_icon_blue.png) &lt;/center&gt;
&lt;center&gt;leanote&lt;/center&gt;
&lt;p&gt;链接:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://leanote.leanote.com&quot;&gt;这是去往Leanote官方博客的链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-标题&quot;&gt;3. 标题&lt;/h2&gt;

&lt;p&gt;以下是各级标题, 最多支持5级标题&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# h1
## h2
### h3
#### h4
##### h4
###### h5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;4-代码&quot;&gt;4. 代码&lt;/h2&gt;

&lt;p&gt;示例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function get(key) {
    return m[key];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码高亮示例:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* nth element in the fibonacci series.
* @param n &amp;gt;= 0
* @return the nth element, &amp;gt;= 0.
*/&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;empCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
 
   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;salary&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;5-markdown-扩展&quot;&gt;5. Markdown 扩展&lt;/h1&gt;

&lt;p&gt;Markdown 扩展支持:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;表格&lt;/li&gt;
  &lt;li&gt;定义型列表&lt;/li&gt;
  &lt;li&gt;Html 标签&lt;/li&gt;
  &lt;li&gt;脚注&lt;/li&gt;
  &lt;li&gt;todo list&lt;/li&gt;
  &lt;li&gt;目录&lt;/li&gt;
  &lt;li&gt;时序图与流程图&lt;/li&gt;
  &lt;li&gt;MathJax 公式&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;51-表格&quot;&gt;5.1 表格&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Item&lt;/th&gt;
      &lt;th&gt;Value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Computer&lt;/td&gt;
      &lt;td&gt;$1600&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Phone&lt;/td&gt;
      &lt;td&gt;$12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Pipe&lt;/td&gt;
      &lt;td&gt;$1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以指定对齐方式, 如Item列左对齐, Value列右对齐, Qty列居中对齐&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Item&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Value&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Qty&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Computer&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;$1600&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Phone&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;$12&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Pipe&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;$1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;234&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;52-定义型列表&quot;&gt;5.2 定义型列表&lt;/h2&gt;

&lt;dl&gt;
  &lt;dt&gt;名词 1&lt;/dt&gt;
  &lt;dd&gt;定义 1（左侧有一个可见的冒号和四个不可见的空格）&lt;/dd&gt;
  &lt;dt&gt;代码块 2&lt;/dt&gt;
  &lt;dd&gt;这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;代码块（左侧有八个不可见的空格）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;h2 id=&quot;53-html-标签&quot;&gt;5.3 Html 标签&lt;/h2&gt;

&lt;p&gt;支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;th rowspan=&quot;2&quot;&amp;gt;值班人员&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;星期一&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;星期二&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;星期三&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;李强&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;张明&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;王平&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;
        &lt;th&gt;星期一&lt;/th&gt;
        &lt;th&gt;星期二&lt;/th&gt;
        &lt;th&gt;星期三&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;李强&lt;/td&gt;
        &lt;td&gt;张明&lt;/td&gt;
        &lt;td&gt;王平&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;, 如果想对图片的宽度和高度进行控制, 你也可以通过img标签, 如:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://leanote.com/images/logo/leanote_icon_blue.png&quot; width=&quot;50px&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;54-脚注&quot;&gt;5.4 脚注&lt;/h2&gt;

&lt;p&gt;Leanote[^footnote]来创建一个脚注
  [^footnote]: Leanote是一款强大的开源云笔记产品.&lt;/p&gt;

&lt;h2 id=&quot;55-todo-list&quot;&gt;5.5 todo list&lt;/h2&gt;

&lt;p&gt;Leanote 近期任务安排:&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;bbs 维护&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Desktop 发布新版
    &lt;ul class=&quot;task-list&quot;&gt;
      &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Markdown编辑器添加Todo list&lt;/li&gt;
      &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;修复白屏问题&lt;/li&gt;
      &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;修复issue3&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Leanote 维护
    &lt;ul class=&quot;task-list&quot;&gt;
      &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;修复issue4&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;56-目录&quot;&gt;5.6 目录&lt;/h2&gt;

&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;[TOC]&lt;/code&gt; 在文档中插入目录, 如:&lt;/p&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;57-时序图与流程图&quot;&gt;5.7 时序图与流程图&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-sequence&quot;&gt;Alice-&amp;gt;Bob: Hello Bob, how are you?
Note right of Bob: Bob thinks
Bob--&amp;gt;Alice: I am good thanks!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;流程图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-flow&quot;&gt;st=&amp;gt;start: Start
e=&amp;gt;end
op=&amp;gt;operation: My Operation
cond=&amp;gt;condition: Yes or No?
 
st-&amp;gt;op-&amp;gt;cond
cond(yes)-&amp;gt;e
cond(no)-&amp;gt;op
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt; 更多关于时序图与流程图的语法请参考:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://bramp.github.io/js-sequence-diagrams/&quot;&gt;时序图语法&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://adrai.github.io/flowchart.js&quot;&gt;流程图语法&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;58-mathjax-公式&quot;&gt;5.8 MathJax 公式&lt;/h2&gt;

&lt;p&gt;$ 表示行内公式：&lt;/p&gt;

&lt;p&gt;质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。&lt;/p&gt;

&lt;p&gt;$$ 表示整行公式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{i=1}^n a_i=0&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}&lt;/script&gt;

&lt;p&gt;更复杂的公式:
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\begin{eqnarray}
\vec\nabla \times (\vec\nabla f) &amp; = &amp; 0  \cdots\cdots梯度场必是无旋场\\
\vec\nabla \cdot(\vec\nabla \times \vec F) &amp; = &amp; 0\cdots\cdots旋度场必是无散场\\
\vec\nabla \cdot (\vec\nabla f) &amp; = &amp; {\vec\nabla}^2f\\
\vec\nabla \times(\vec\nabla \times \vec F) &amp; = &amp; \vec\nabla(\vec\nabla \cdot \vec F) - {\vec\nabla}^2 \vec F\\
\end{eqnarray} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;访问 &lt;a href=&quot;http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference&quot;&gt;MathJax&lt;/a&gt; 参考更多使用方法。&lt;/p&gt;
</description>
				<pubDate>Sat, 09 Jun 2018 11:10:51 +0800</pubDate>
				<link>http://localhost:4000/markdown/2018/06/09/grama-of-markdown.html</link>
				<guid isPermaLink="true">http://localhost:4000/markdown/2018/06/09/grama-of-markdown.html</guid>
			</item>
		
			<item>
				<title>《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型</title>
				<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;
最近看完了 LSTM 的一些外文资料，主要参考了 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//colah.github.io/posts/2015-08-Understanding-LSTMs/&quot;&gt;Colah 的 blog&lt;/a&gt;以及 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//karpathy.github.io/&quot;&gt;Andrej Karpathy blog&lt;/a&gt;的一些关于 RNN 和 LSTM 的材料，准备动手去实现一个 LSTM 模型。代码的基础框架来自于 Udacity 上深度学习纳米学位的课程（付费课程）的一个 demo，我刚开始看代码的时候真的是一头雾水，很多东西没有理解，后来反复查阅资料，并我重新对代码进行了学习和修改，对步骤进行了进一步的剖析，下面将一步步用 TensorFlow 来构建 LSTM 模型进行文本学习并试图去生成新的文本。本篇文章比较适合新手去操作，LSTM 层采用的是 BasicLSTMCell。&lt;/p&gt;

&lt;p&gt;关于 RNN 与 LSTM 模型本文不做介绍，详情去查阅资料过着去看上面的 blog 链接，讲的很清楚啦。这篇文章主要是偏向实战，来自己动手构建 LSTM 模型。&lt;/p&gt;

&lt;p&gt;数据集来自于外文版《安娜卡列妮娜》书籍的文本文档（本文后面会提供整个 project 的 git 链接）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;工具介绍&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;语言：Python 3&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;包：TensorFlow 及其它数据处理包（见代码中）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编辑器：jupyter notebook&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线上 GPU：floyd&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;正文部分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;正文部分主要包括以下四个部分：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- 数据预处理：&lt;/strong&gt;加载数据、转换数据、分割数据 mini-batch&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- 模型构建：&lt;/strong&gt;输入层，LSTM 层，输出层，训练误差，loss，optimizer&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- 模型训练：&lt;/strong&gt;设置模型参数对模型进行训练&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- 生成新文本：&lt;/strong&gt;训练新的文本&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主题：整个文本将基于《安娜卡列妮娜》这本书的英文文本作为 LSTM 模型的训练数据，输入为单个字符，通过学习整个英文文档的字符（包括字母和标点符号等）来进行文本生成。在开始建模之前，我们首先要明确我们的输入和输出。即输入是字符，输出是预测出的新字符。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一. 数据预处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在开始模型之前，我们首先要导入需要的包：&lt;/p&gt;

&lt;pre style=&quot;font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;&quot;&gt;
import timeimport numpy as npimport tensorflow as tf
&lt;/pre&gt;

&lt;p&gt;这一部分主要包括了数据的转换与 mini-batch 的分割步骤。&lt;/p&gt;

&lt;p&gt;首先我们来进行数据的加载与编码转换。由于我们是基于&lt;strong&gt;字符&lt;/strong&gt;（字母和标点符号等单个字符串，以下统称为&lt;strong&gt;字符&lt;/strong&gt;）进行模型构建，也就是说我们的输入和输出都是字符。举个栗子，假如我们有一个单词 “hello”，我们想要基于这个单词构建 LSTM，那么希望的到的结果是，输入 “h”，预测下一个字母为 “e”；输入 “e” 时，预测下一个字母为 “l”，等等。&lt;/p&gt;

&lt;p&gt;因此我们的输入便是一个个字母，下面我们将文章进行转换。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927d9ffe1bc5.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的代码主要完成了下面三个任务：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- 得到了文章中所有的字符集合 vocab&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- 得到一个字符 - 数字的映射 vocab_to_int&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- 得到一个数字 - 字符的映射 int_to_vocab&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- 对原文进行转码后的列表 encoded&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;完成了前面的数据预处理操作，接下来就是要划分我们的数据集，在这里我们使用 mini-batch 来进行模型训练，那么我们要如何划分数据集呢？在进行 mini-batch 划分之前，我们先来了解几个概念。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927da20000d1.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假如我们目前手里有一个序列 1-12，我们接下来以这个序列为例来说明划分 mini-batch 中的几个概念。首先我们回顾一下，在 DNN 和 CNN 中，我们都会将数据分 batch 输入给神经网络，加入我们有 100 个样本，如果设置我们的 batch_size=10，那么意味着每次我们都会向神经网络输入 10 个样本进行训练调整参数。同样的，在 LSTM 中，batch_size 意味着每次向网络输入多少个样本，在上图中，当我们设置 batch_size=2 时，我们会将整个序列划分为 6 个 batch，每个 batch 中有两个数字。&lt;/p&gt;

&lt;p&gt;然而由于 RNN 中存在着 “记忆”，也就是循环。事实上一个循环神经网络能够被看做是多个相同神经网络的叠加，在这个系统中，每一个网络都会传递信息给下一个。上面的图中，我们可以看到整个 RNN 网络由三个相同的神经网络单元叠加起来的序列。那么在这里就有了第二个概念 sequence_length（也叫 steps），中文叫序列长度。上图中序列长度是 3，可以看到将三个字符作为了一个序列。&lt;/p&gt;

&lt;p&gt;有了上面两个概念，我们来规范一下后面的定义。我们定义一个 batch 中的序列个数为 N（即 batch_size），定义单个序列长度为 M（也就是我们的 num_steps）。那么实际上我们每个 batch 是一个N×M的数组，&lt;strong&gt;相当于我们的每个 batch 中有N×M个字符&lt;/strong&gt;。在上图中，当我们设置 N=2， M=3 时，我们可以得到每个 batch 的大小为 2 x 3 = 6 个字符，整个序列可以被分割成 12 / 6 = 2 个 batch。&lt;/p&gt;

&lt;p&gt;基于上面的分析，我们下面来进行 mini-batch 的分割：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927db229197c.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的代码定义了一个 generator，调用函数会返回一个 generator 对象，我们可以获取一个 batch。&lt;/p&gt;

&lt;p&gt;经过上面的步骤，我们已经完成了对数据集的预处理。下一步我们开始构建模型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二. 模型构建&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;模型构建部分主要包括了输入层，LSTM 层，输出层，loss，optimizer 等部分的构建，我们将一块一块来进行实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 输入层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在数据预处理阶段，我们定义了 mini-batch 的分割函数，输入层的 size 取决于我们设置 batch 的 size（n_seqs × n_steps），下面我们首先构建输入层。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927db6ec36f5.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同样的，输出层的（因为输入一个字符，同样会输出一个字符）。除了输入输出外，我们还定义了 keep_prob 参数用来在后面控制 dropout 的保留结点数。关于 dropout 正则化请参考&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Dropout_%28neural_networks%29&quot;&gt;链接&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.LSTM 层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;LSTM 层是整个神经网络的关键部分。TensorFlow 中，tf.contrib.rnn 模块中有 BasicLSTMCell 和 LSTMCell 两个包，它们的区别在于：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BasicLSTMCell does not allow cell clipping, a projection layer, and does not use peep-hole connections: it is the basic baseline.（来自 TensorFlow 官网）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在这里我们仅使用基本模块 BasicLSTMCell。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927db94071d4.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的代码中，我并没有使用 tf.contrib.rnn 模块，是因为我在使用远程 floyd 的 GPU 运行代码时候告诉我找不到这个模块，可以用 tf.nn.run_cell.BasicLSTMCell 替代。构建好 LSTM cell 后，为了防止过拟合，在它的隐层添加了 dropout 正则。&lt;/p&gt;

&lt;p&gt;后面的 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.tensorflow.org/versions/master/api_docs/python/tf/contrib/rnn/MultiRNNCell&quot;&gt;MultiRNNCell&lt;/a&gt;实现了对基本 LSTM cell 的顺序堆叠，它接收的是 cell 对象组成的 list。最后 initial_state 定义了初始 cell state。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 输出层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;到目前为止，我们的输入和 LSTM 层都已经构建完毕。接下来就要构造我们的输出层，输出层采用 softmax，它与 LSTM 进行全连接。对于每一个字符来说，它经过 LSTM 后的输出大小是1×L（L 为 LSTM cell 隐层的结点数量），我们上面也分析过输入一个 N x M 的 batch，我们从 LSTM 层得到的输出为N×M×L，要将这个输出与 softmax 全连接层建立连接，就需要对 LSTM 的输出进行重塑，变成( N * M ) × L 的一个 2D 的 tensor。softmax 层的结点数应该是 vocab 的大小（我们要计算概率分布）。因此整个 LSTM 层到 softmax 层的大小为L×vocab_size。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927dc363ceef.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将数据重塑后，我们对 LSTM 层和 softmax 层进行连接。并计算 logits 和 softmax 后的概率分布。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 训练误差计算&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;至此我们已经完成了整个网络的构建，接下来要定义 train loss 和 optimizer。我们知道从 sotfmax 层输出的是概率分布，因此我们要对 targets 进行 one-hot 编码。我们采用 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.tensorflow.org/versions/master/api_docs/python/tf/nn/softmax_cross_entropy_with_logits&quot;&gt;softmax_cross_entropy_with_logits&lt;/a&gt;交叉熵来计算 loss。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927dc56b0fe2.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.Optimizer&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道 RNN 会遇到&lt;strong&gt;梯度爆炸（gradients exploding）&lt;/strong&gt;和&lt;strong&gt;梯度弥散（gradients disappearing)&lt;/strong&gt; 的问题。LSTM 解决了梯度弥散的问题，但是 gradients 仍然可能会爆炸，因此我们采用 gradient clippling 的方式来防止梯度爆炸。即通过设置一个阈值，当 gradients 超过这个阈值时，就将它重置为阈值大小，这就保证了梯度不会变得很大。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927dc7620d04.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//www.tensorflow.org/api_docs/python/tf/clip_by_global_norm&quot;&gt;tf.clip_by_global_norm&lt;/a&gt;会返回 clip 以后的 gradients 以及 global_norm。整个学习过程采用 AdamOptimizer&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. 模型组合&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;经过上面五个步骤，我们完成了所有的模块设置。下面我们来将这些部分组合起来，构建一个类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927dc98f2b8f.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们使用 tf.nn.dynamic_run 来运行 RNN 序列。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三. 模型训练&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在模型训练之前，我们首先初始化一些参数，我们的参数主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;batch_size: 单个 batch 中序列的个数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;num_steps: 单个序列中字符数目&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lstm_size: 隐层结点个数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;num_layers: LSTM 层个数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;learning_rate: 学习率&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;keep_prob: 训练时 dropout 层中保留结点比例&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927dcc690a67.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是我自己设置的一些参数，具体一些调参经验可以参考 &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/karpathy/char-rnn%23tips-and-tricks&quot;&gt;Andrej Karpathy 的 git 上的建议&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;参数设置完毕后，离运行整个 LSTM 就差一步啦，下面我们来运行整个模型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927dce73a1a6.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我这里设置的迭代次数为 20 次，并且在代码运行中我们设置了结点的保存，设置了每运行 200 次进行一次变量保存，这样的好处是有利于我们后面去直观地观察在整个训练过程中文本生成的结果是如何一步步 “进化” 的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四. 文本生成&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;经过漫长的模型训练，我们得到了一系列训练过程中保存下来的参数，可以利用这些参数来进行文本生成啦。当我们输入一个字符时，它会预测下一个，我们再将这个新的字符输入模型，就可以一直不断地生成字符，从而形成文本。&lt;/p&gt;

&lt;p&gt;为了减少噪音，每次的预测值我会选择最可能的前 5 个进行随机选择，比如输入 h，预测结果概率最大的前五个为[o,i,e,u,b]，我们将随机从这五个中挑选一个作为新的字符，让过程加入随机因素会减少一些噪音的生成。&lt;/p&gt;

&lt;p&gt;代码封装了两个函数来做文本生成，具体请参看文章尾部的 git 链接中的源码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;训练步数：200&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当训练步数为 200 的时候，LSTM 生成的文本大概长下面这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927dd51b5342.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看起来像是字符的随机组合，但是可以看到有一些单词例如 hat，her 等已经出现，并且生成了成对的引号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;训练步数：1000&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927dd6a403f9.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当训练步数到达 1000 的时候，已经开始有简单的句子出现，并且单词看起来似乎不是那么乱了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;训练步数：2000&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927dd7e5353a.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当训练步数达到 2000 的时候，单词和句子看起来已经有所规范。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;训练步数：3960&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://static.leiphone.com/uploads/new/article/740_740/201705/5927dd8f90f48.png?imageMogr2/format/jpg/quality/90&quot; alt=&quot;《安娜卡列尼娜》文本生成——利用 TensorFlow 构建 LSTM 模型&quot; /&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当训练结束时（本文仅训练了 3960 步），生成的文本已经有小部分可以读的比较通顺了，而且很少有单词拼写的错误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五. 总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;整个文章通过构建 LSTM 模型完成了对《安娜卡列宁娜》文本的学习并且基于学习成果生成了新的文本。&lt;/p&gt;

&lt;p&gt;通过观察上面的生成文本，我们可以看出随着训练步数的增加，模型的训练误差在持续减少。本文仅设置了 20 次迭代，尝试更大次数的迭代可能会取得更好的效果。&lt;/p&gt;

&lt;p&gt;个人觉得 LSTM 对于文本的学习能力还是很强，后面可能将针对中文文本构造一些学习模型，应该会更有意思！&lt;/p&gt;

&lt;p&gt;我对 RNN 也是在不断地探索与学习中，文中不免会有一些错误和谬误，恳请各位指正，非常感谢！&lt;/p&gt;
</description>
				<pubDate>Sun, 03 Jun 2018 14:10:51 +0800</pubDate>
				<link>http://localhost:4000/machine_learning/2018/06/03/test1.html</link>
				<guid isPermaLink="true">http://localhost:4000/machine_learning/2018/06/03/test1.html</guid>
			</item>
		
			<item>
				<title>Read Me</title>
				<description>&lt;h1 id=&quot;jekyll-xixia&quot;&gt;Jekyll Xixia&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Get it from &lt;a href=&quot;https://github.com/zxixia/jekyll-xixia&quot;&gt;github&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;See the &lt;a href=&quot;http://xixia.info/jekyll-xixia/&quot;&gt;live demo&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;See it &lt;a href=&quot;http://xixia.info/&quot;&gt;in action on my own blog&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A simple and clean Jekyll theme using &lt;a href=&quot;http://getbootstrap.com&quot;&gt;bootstrap&lt;/a&gt;
(not to be confused with jekyll-bootstrap) that’s easy to modify and very
modular in component and element reuse.&lt;/p&gt;

&lt;p&gt;The theme works well on mobile phones, using a collapsable nav bar and hiding the
sidebar. The links pane in the sidebar is available on mobile through the nav menu,
and you can do the same thing for any other sections added to the sidebar.&lt;/p&gt;

&lt;p&gt;Don’t forget to occassionally merge against my upstream repository so you can get
the latest changes. Pull requests are encouraged and accepted!&lt;/p&gt;

&lt;h1 id=&quot;preview&quot;&gt;Preview&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;//assets/images/preview.png&quot; alt=&quot;Xixia&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;license&quot;&gt;License&lt;/h1&gt;

&lt;p&gt;The content of this theme is distributed and licensed under a
&lt;img src=&quot;/assets/images/cc_by_88x31.png&quot; alt=&quot;License Badge&quot; /&gt;
&lt;a href=&quot;https://creativecommons.org/licenses/by/4.0/legalcode&quot;&gt;Creative Commons Attribution 4.0 License&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This license lets others distribute, remix, tweak, and build upon your work,
even commercially, as long as they credit you for the original creation. This
is the most accommodating of licenses offered. Recommended for maximum
dissemination and use of licensed materials.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In other words: you can do anything you want with this theme on any site, just please
provide a link to &lt;a href=&quot;https://github.com/zxixia/jekyll-xixia&quot;&gt;the original theme on github&lt;/a&gt;
so I get credit for the original design. Beyond that, have at it!&lt;/p&gt;

&lt;h1 id=&quot;thanks&quot;&gt;Thanks&lt;/h1&gt;

&lt;p&gt;1，&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2，&lt;a href=&quot;http://getbootstrap.com/&quot;&gt;Bootstrap&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3，&lt;a href=&quot;https://github.com/&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4，&lt;a href=&quot;https://github.com/scotte/jekyll-clean&quot;&gt;Jekyll Clean Theme&lt;/a&gt;&lt;/p&gt;

</description>
				<pubDate>Tue, 19 Sep 2017 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/other/2017/09/19/README.html</link>
				<guid isPermaLink="true">http://localhost:4000/other/2017/09/19/README.html</guid>
			</item>
		
			<item>
				<title>How to get beautiful ASCII pics and ASCII text</title>
				<description>&lt;h3 id=&quot;1ascii-generator&quot;&gt;1，ASCII Generator&lt;/h3&gt;

&lt;p&gt;In &lt;a href=&quot;http://www.network-science.de/ascii/&quot;&gt;ASCII Generator&lt;/a&gt;, you can generate your ASCII texts。&lt;/p&gt;

&lt;p&gt;Such like the &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XIXIA&lt;/code&gt;&lt;/strong&gt;！&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-v&quot; data-lang=&quot;v&quot;&gt;____  ___._______  ___.___   _____   
\   \/  /|   \   \/  /|   | /  _  \  
 \     / |   |\     / |   |/  /_\  \ 
 /     \ |   |/     \ |   /    |    \
/___/\  \|___/___/\  \|___\____|__  /
      \_/          \_/            \/ 

------------------------------------
___   ___  __  ___   ___  __       ___      
\  \ /  / |  | \  \ /  / |  |     /   \     
 \  V  /  |  |  \  V  /  |  |    /  ^  \    
  &amp;gt;   &amp;lt;   |  |   &amp;gt;   &amp;lt;   |  |   /  /_\  \   
 /  .  \  |  |  /  .  \  |  |  /  _____  \  
/__/ \__\ |__| /__/ \__\ |__| /__/     \__\ 

------------------------------------
__   _________   _______          
\ \ / /_   _\ \ / /_   _|   /\    
 \ V /  | |  \ V /  | |    /  \   
  &amp;gt; &amp;lt;   | |   &amp;gt; &amp;lt;   | |   / /\ \  
 / . \ _| |_ / . \ _| |_ / ____ \ 
/_/ \_\_____/_/ \_\_____/_/    \_\   &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;2chriscom&quot;&gt;2，Chris.com&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.chris.com/ascii/&quot;&gt;Chris.com&lt;/a&gt; collects a lot of ASCII pics, such like the world map：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-v&quot; data-lang=&quot;v&quot;&gt;-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
           . _..::__:  ,-&quot;-&quot;._        |7       ,     _,.__
   _.___ _ _&amp;lt;_&amp;gt;`!(._`.`-.    /         _._     `_ ,_/  '  '-._.---.-.__
&amp;gt;.{     &quot; &quot; `-==,',._\{  \  / {)      / _ &quot;&amp;gt;_,-' `                mt-2_
  \_.:--.       `._ )`^-. &quot;'       , [_/(                       __,/-'
 '&quot;'     \         &quot;    _L        oD_,--'                )     /. (|
          |           ,'          _)_.\\._&amp;lt;&amp;gt; 6              _,' /  '
          `.         /           [_/_'` `&quot;(                &amp;lt;'}  )
           \\    .-. )           /   `-'&quot;..' `:.#          _)  '
    `        \  (  `(           /         `:\  &amp;gt; \  ,-^.  /' '
              `._,   &quot;&quot;         |           \`'   \|   ?_)  {\
                 `=.---.        `._._       ,'     &quot;`  |' ,- '.
                   |    `-._         |     /          `:`&amp;lt;_|h--._
                   (        &amp;gt;        .     | ,          `=.__.`-'\
                    `.     /         |     |{|              ,-.,\     .
                     |   ,'           \   / `'            ,&quot;     \
                     |  /              |_'                |  __  /
                     | |                                  '-'  `-'   \.
                     |/                                         &quot;    /
                     \.                                             '

                      ,/            ______._.--._ _..---.---------._
     ,-----&quot;-..?----_/ )      __,-'&quot;             &quot;                  (
-.._(                  `-----'                                       `-
-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
Map (C) 1998 Matthew Thomas. Freely usable if this line is included. &amp;lt;-&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
Elephant.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-v&quot; data-lang=&quot;v&quot;&gt;              ___.-~&quot;~-._   __....__
            .'    `    \ ~&quot;~        ``-.
           /` _      )  `\              `\
          /`  a)    /     |               `\
         :`        /      |                 \
    &amp;lt;`-._|`  .-.  (      /   .            `;\\
     `-. `--'_.'-.;\___/'   .      .       | \\
  _     /:--`     |        /     /        .'  \\
 (&quot;\   /`/        |       '     '         /    :`;
 `\'\_/`/         .\     /`~`=-.:        /     ``
   `._.'          /`\    |      `\      /(
                 /  /\   |        `Y   /  \
           jgs  J  /  Y  |         |  /`\  \
               /  |   |  |         |  |  |  |
              &quot;---&quot;  /___|        /___|  /__|
                     '&quot;&quot;&quot;         '&quot;&quot;&quot;  '&quot;&quot;&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;3welcome-to-lost-in-xixia&quot;&gt;3，Welcome to lost in Xixia&lt;/h3&gt;
&lt;p&gt;The 404 page of Xixia, is based on ASCII pics and ASCII texts!&lt;/p&gt;

&lt;p&gt;So, warmly welcome you to lost in &lt;a href=&quot;http://xixia.info/welcome-lost-in-xixia&quot;&gt;Xixia&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;thanks&quot;&gt;Thanks：&lt;/h3&gt;

&lt;p&gt;1，&lt;a href=&quot;http://www.chris.com/ascii/&quot;&gt;Chris.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2，&lt;a href=&quot;http://www.network-science.de/ascii/&quot;&gt;ASCII Generator&lt;/a&gt;&lt;/p&gt;

</description>
				<pubDate>Fri, 15 Sep 2017 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/programmer/2017/09/15/ascii-art-and-text.html</link>
				<guid isPermaLink="true">http://localhost:4000/programmer/2017/09/15/ascii-art-and-text.html</guid>
			</item>
		
			<item>
				<title>Welcome to Jekyll!</title>
				<description>&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;

</description>
				<pubDate>Tue, 05 Sep 2017 14:10:51 +0800</pubDate>
				<link>http://localhost:4000/jekyll/2017/09/05/welcome-to-jekyll.html</link>
				<guid isPermaLink="true">http://localhost:4000/jekyll/2017/09/05/welcome-to-jekyll.html</guid>
			</item>
		
			<item>
				<title>Readme of Jekyll!</title>
				<description>&lt;h1 id=&quot;jekyll&quot;&gt;&lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://rubygems.org/gems/jekyll&quot;&gt;&lt;img src=&quot;https://img.shields.io/gem/v/jekyll.svg&quot; alt=&quot;Gem Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://travis-ci.org/jekyll/jekyll&quot;&gt;&lt;img src=&quot;https://img.shields.io/travis/jekyll/jekyll/master.svg?label=Linux%20build&quot; alt=&quot;Linux Build Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://ci.appveyor.com/project/jekyll/jekyll/branch/master&quot;&gt;&lt;img src=&quot;https://img.shields.io/appveyor/ci/jekyll/jekyll/master.svg?label=Windows%20build&quot; alt=&quot;Windows Build status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://codeclimate.com/github/jekyll/jekyll/coverage&quot;&gt;&lt;img src=&quot;https://img.shields.io/codeclimate/coverage/github/jekyll/jekyll.svg&quot; alt=&quot;Test Coverage&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://codeclimate.com/github/jekyll/jekyll&quot;&gt;&lt;img src=&quot;https://img.shields.io/codeclimate/github/jekyll/jekyll.svg&quot; alt=&quot;Code Climate&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://gemnasium.com/jekyll/jekyll&quot;&gt;&lt;img src=&quot;https://img.shields.io/gemnasium/jekyll/jekyll.svg&quot; alt=&quot;Dependency Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://hakiri.io/github/jekyll/jekyll/master&quot;&gt;&lt;img src=&quot;https://hakiri.io/github/jekyll/jekyll/master.svg&quot; alt=&quot;Security&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Jekyll is a simple, blog-aware, static site generator perfect for personal, project, or organization sites. Think of it like a file-based CMS, without all the complexity. Jekyll takes your content, renders Markdown and Liquid templates, and spits out a complete, static website ready to be served by Apache, Nginx or another web server. Jekyll is the engine behind &lt;a href=&quot;https://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt;, which you can use to host sites right from your GitHub repositories.&lt;/p&gt;

&lt;h2 id=&quot;philosophy&quot;&gt;Philosophy&lt;/h2&gt;

&lt;p&gt;Jekyll does what you tell it to do — no more, no less. It doesn’t try to outsmart users by making bold assumptions, nor does it burden them with needless complexity and configuration. Put simply, Jekyll gets out of your way and allows you to concentrate on what truly matters: your content.&lt;/p&gt;

&lt;p&gt;See: https://jekyllrb.com/philosophy&lt;/p&gt;

&lt;h2 id=&quot;having-trouble&quot;&gt;Having trouble?&lt;/h2&gt;

&lt;p&gt;See: https://jekyllrb.com/docs/troubleshooting/&lt;/p&gt;

&lt;h2 id=&quot;getting-started&quot;&gt;Getting Started&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jekyllrb.com/docs/installation/&quot;&gt;Install&lt;/a&gt; the gem&lt;/li&gt;
  &lt;li&gt;Read up about its &lt;a href=&quot;https://jekyllrb.com/docs/usage/&quot;&gt;Usage&lt;/a&gt; and &lt;a href=&quot;https://jekyllrb.com/docs/configuration/&quot;&gt;Configuration&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Take a gander at some existing &lt;a href=&quot;https://wiki.github.com/jekyll/jekyll/sites&quot;&gt;Sites&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/jekyll/jekyll/fork&quot;&gt;Fork&lt;/a&gt; and &lt;a href=&quot;https://jekyllrb.com/docs/contributing/&quot;&gt;Contribute&lt;/a&gt; your own modifications&lt;/li&gt;
  &lt;li&gt;Have questions? Check out our official forum community &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt; or &lt;a href=&quot;https://botbot.me/freenode/jekyll/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#jekyll&lt;/code&gt; on irc.freenode.net&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;code-of-conduct&quot;&gt;Code of Conduct&lt;/h2&gt;

&lt;p&gt;In order to have a more open and welcoming community, Jekyll adheres to a
&lt;a href=&quot;CODE_OF_CONDUCT.markdown&quot;&gt;code of conduct&lt;/a&gt; adapted from the Ruby on Rails code of
conduct.&lt;/p&gt;

&lt;p&gt;Please adhere to this code of conduct in any interactions you have in the
Jekyll community. It is strictly enforced on all official Jekyll
repositories, websites, and resources. If you encounter someone violating
these terms, please let a &lt;a href=&quot;https://github.com/orgs/jekyll/teams/affinity-team-captains/members&quot;&gt;team captain&lt;/a&gt; know and we will address it as soon as possible.&lt;/p&gt;

&lt;h2 id=&quot;diving-in&quot;&gt;Diving In&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://import.jekyllrb.com/docs/home/&quot;&gt;Migrate&lt;/a&gt; from your previous system&lt;/li&gt;
  &lt;li&gt;Learn how the &lt;a href=&quot;https://jekyllrb.com/docs/frontmatter/&quot;&gt;YAML Front Matter&lt;/a&gt; works&lt;/li&gt;
  &lt;li&gt;Put information on your site with &lt;a href=&quot;https://jekyllrb.com/docs/variables/&quot;&gt;Variables&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Customize the &lt;a href=&quot;https://jekyllrb.com/docs/permalinks/&quot;&gt;Permalinks&lt;/a&gt; your posts are generated with&lt;/li&gt;
  &lt;li&gt;Use the built-in &lt;a href=&quot;https://jekyllrb.com/docs/templates/&quot;&gt;Liquid Extensions&lt;/a&gt; to make your life easier&lt;/li&gt;
  &lt;li&gt;Use custom &lt;a href=&quot;https://jekyllrb.com/docs/plugins/&quot;&gt;Plugins&lt;/a&gt; to generate content specific to your site&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;See the &lt;a href=&quot;https://github.com/jekyll/jekyll/blob/master/LICENSE&quot;&gt;LICENSE&lt;/a&gt; file.&lt;/p&gt;
</description>
				<pubDate>Tue, 05 Sep 2017 14:10:51 +0800</pubDate>
				<link>http://localhost:4000/jekyll/2017/09/05/reademe-of-jekyll.html</link>
				<guid isPermaLink="true">http://localhost:4000/jekyll/2017/09/05/reademe-of-jekyll.html</guid>
			</item>
		
			<item>
				<title>Another copy of the Readme of Jekyll!</title>
				<description>&lt;h1 id=&quot;jekyll&quot;&gt;&lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://rubygems.org/gems/jekyll&quot;&gt;&lt;img src=&quot;https://img.shields.io/gem/v/jekyll.svg&quot; alt=&quot;Gem Version&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://travis-ci.org/jekyll/jekyll&quot;&gt;&lt;img src=&quot;https://img.shields.io/travis/jekyll/jekyll/master.svg?label=Linux%20build&quot; alt=&quot;Linux Build Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://ci.appveyor.com/project/jekyll/jekyll/branch/master&quot;&gt;&lt;img src=&quot;https://img.shields.io/appveyor/ci/jekyll/jekyll/master.svg?label=Windows%20build&quot; alt=&quot;Windows Build status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://codeclimate.com/github/jekyll/jekyll/coverage&quot;&gt;&lt;img src=&quot;https://img.shields.io/codeclimate/coverage/github/jekyll/jekyll.svg&quot; alt=&quot;Test Coverage&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://codeclimate.com/github/jekyll/jekyll&quot;&gt;&lt;img src=&quot;https://img.shields.io/codeclimate/github/jekyll/jekyll.svg&quot; alt=&quot;Code Climate&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://gemnasium.com/jekyll/jekyll&quot;&gt;&lt;img src=&quot;https://img.shields.io/gemnasium/jekyll/jekyll.svg&quot; alt=&quot;Dependency Status&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://hakiri.io/github/jekyll/jekyll/master&quot;&gt;&lt;img src=&quot;https://hakiri.io/github/jekyll/jekyll/master.svg&quot; alt=&quot;Security&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Jekyll is a simple, blog-aware, static site generator perfect for personal, project, or organization sites. Think of it like a file-based CMS, without all the complexity. Jekyll takes your content, renders Markdown and Liquid templates, and spits out a complete, static website ready to be served by Apache, Nginx or another web server. Jekyll is the engine behind &lt;a href=&quot;https://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt;, which you can use to host sites right from your GitHub repositories.&lt;/p&gt;

&lt;h2 id=&quot;philosophy&quot;&gt;Philosophy&lt;/h2&gt;

&lt;p&gt;Jekyll does what you tell it to do — no more, no less. It doesn’t try to outsmart users by making bold assumptions, nor does it burden them with needless complexity and configuration. Put simply, Jekyll gets out of your way and allows you to concentrate on what truly matters: your content.&lt;/p&gt;

&lt;p&gt;See: https://jekyllrb.com/philosophy&lt;/p&gt;

&lt;h2 id=&quot;having-trouble&quot;&gt;Having trouble?&lt;/h2&gt;

&lt;p&gt;See: https://jekyllrb.com/docs/troubleshooting/&lt;/p&gt;

&lt;h2 id=&quot;getting-started&quot;&gt;Getting Started&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jekyllrb.com/docs/installation/&quot;&gt;Install&lt;/a&gt; the gem&lt;/li&gt;
  &lt;li&gt;Read up about its &lt;a href=&quot;https://jekyllrb.com/docs/usage/&quot;&gt;Usage&lt;/a&gt; and &lt;a href=&quot;https://jekyllrb.com/docs/configuration/&quot;&gt;Configuration&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Take a gander at some existing &lt;a href=&quot;https://wiki.github.com/jekyll/jekyll/sites&quot;&gt;Sites&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/jekyll/jekyll/fork&quot;&gt;Fork&lt;/a&gt; and &lt;a href=&quot;https://jekyllrb.com/docs/contributing/&quot;&gt;Contribute&lt;/a&gt; your own modifications&lt;/li&gt;
  &lt;li&gt;Have questions? Check out our official forum community &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt; or &lt;a href=&quot;https://botbot.me/freenode/jekyll/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#jekyll&lt;/code&gt; on irc.freenode.net&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;code-of-conduct&quot;&gt;Code of Conduct&lt;/h2&gt;

&lt;p&gt;In order to have a more open and welcoming community, Jekyll adheres to a
&lt;a href=&quot;CODE_OF_CONDUCT.markdown&quot;&gt;code of conduct&lt;/a&gt; adapted from the Ruby on Rails code of
conduct.&lt;/p&gt;

&lt;p&gt;Please adhere to this code of conduct in any interactions you have in the
Jekyll community. It is strictly enforced on all official Jekyll
repositories, websites, and resources. If you encounter someone violating
these terms, please let a &lt;a href=&quot;https://github.com/orgs/jekyll/teams/affinity-team-captains/members&quot;&gt;team captain&lt;/a&gt; know and we will address it as soon as possible.&lt;/p&gt;

&lt;h2 id=&quot;diving-in&quot;&gt;Diving In&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://import.jekyllrb.com/docs/home/&quot;&gt;Migrate&lt;/a&gt; from your previous system&lt;/li&gt;
  &lt;li&gt;Learn how the &lt;a href=&quot;https://jekyllrb.com/docs/frontmatter/&quot;&gt;YAML Front Matter&lt;/a&gt; works&lt;/li&gt;
  &lt;li&gt;Put information on your site with &lt;a href=&quot;https://jekyllrb.com/docs/variables/&quot;&gt;Variables&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Customize the &lt;a href=&quot;https://jekyllrb.com/docs/permalinks/&quot;&gt;Permalinks&lt;/a&gt; your posts are generated with&lt;/li&gt;
  &lt;li&gt;Use the built-in &lt;a href=&quot;https://jekyllrb.com/docs/templates/&quot;&gt;Liquid Extensions&lt;/a&gt; to make your life easier&lt;/li&gt;
  &lt;li&gt;Use custom &lt;a href=&quot;https://jekyllrb.com/docs/plugins/&quot;&gt;Plugins&lt;/a&gt; to generate content specific to your site&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;

&lt;p&gt;See the &lt;a href=&quot;https://github.com/jekyll/jekyll/blob/master/LICENSE&quot;&gt;LICENSE&lt;/a&gt; file.&lt;/p&gt;
</description>
				<pubDate>Tue, 05 Sep 2017 14:10:51 +0800</pubDate>
				<link>http://localhost:4000/jekyll/2017/09/05/another-copy-of-the-reademe-of-jekyll.html</link>
				<guid isPermaLink="true">http://localhost:4000/jekyll/2017/09/05/another-copy-of-the-reademe-of-jekyll.html</guid>
			</item>
		
	</channel>
</rss>
